<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>D</title>
<link rel="stylesheet" href="doc.css" type="text/css">
</head>
<body>

<h1>D</h1>

<dl>

<dt><a name="*DB"><code>*DB</code></a>
<dd>A global constant holding the external symbol <code>{1}</code>, the database
root. All transient symbols in a database can be reached from that root. Except
during debugging, any explicit literal access to symbols in the database should
be avoided, because otherwise a memory leak might occur (The garbage collector
temporarily sets <code>*DB</code> to <code>NIL</code> and restores its value
after collection, thus disposing of all external symbols not currently used in
the program).

<p><pre><code>
: (show *DB)
{1} NIL
   +City {P}
   +Person {3}
-> {1}
: (show '{P})
{P} NIL
   nm (566 . {AhDx})
-> {P}
: (show '{3})
{3} NIL
   tel (681376 . {Agyl})
   nm (1461322 . {2gu7})
-> {3}
</code></pre>

<dt><a name="*Dbg"><code>*Dbg</code></a>
<dd>A boolean variable controlling the <code><a href="ref_.html#$">$</a></code>
(tracing) and <code><a href="ref_.html#!">!</a></code> (breakpoint) functions.
They are enabled when <code>*Dbg</code> is non-<code>NIL</code>.

<p><pre><code>
: (de foo (A B) (* A B))
-> foo
: (trace 'foo)
-> foo
: (foo 3 4)
 foo : 3 4
 foo = 12
-> 12
: (let *Dbg NIL (foo 3 4))
-> 12
</code></pre>

<dt><a name="*Dbs"><code>*Dbs</code></a>
<dd>A global variable holding a list of numbers (block size scale factors, as
needed by <code><a href="refP.html#pool">pool</a></code>). It is typically set
by <code><a href="refD.html#dbs">dbs</a></code>
and <code><a href="refD.html#dbs+">dbs+</a></code>.

<p><pre><code>
: *Dbs
-> (1 2 1 0 2 3 3 3)
</code></pre>

<dt><a name="daemon"><code>(daemon 'sym . prg) -> fun<br>
(daemon '(sym . cls) . prg) -> fun</code></a>
<dd>Inserts <code>prg</code> in the beginning of the function or method body of
<code>sym</code>. Built-in functions (C-function pointer) are automatically
converted to Lisp expressions. See also <code><a
href="refE.html#expr">expr</a></code>, <code><a
href="refP.html#patch">patch</a></code> and <code><a
href="refR.html#redef">redef</a></code>.

<p><pre><code>
: (de hello () (prinl "Hello world!"))
-> hello

: (daemon 'hello (prinl "# This is the hello world program"))
-> (NIL (prinl "# This is the hello world program") (prinl "Hello world!"))
: (hello)
# This is the hello world program
Hello world!
-> "Hello world!"

: (daemon '* (msg 'Multiplying))
-> (@ (msg 'Multiplying) (pass $134532148))
: *
-> (@ (msg 'Multiplying) (pass $134532148))
: (* 1 2 3)
Multiplying
-> 6
</code></pre>

<dt><a name="dat$"><code>(dat$ 'dat ['sym]) -> sym</code></a>
<dd>Formats a <code><a href="refD.html#date">date</a></code> <code>dat</code> in
ISO format, with an optional delimiter character <code>sym</code>. See also
<code><a href="ref_.html#$dat">$dat</a></code>, <code><a
href="refT.html#tim$">tim$</a></code>, <code><a
href="refD.html#datStr">datStr</a></code> and <code><a
href="refD.html#datSym">datSym</a></code>.

<p><pre><code>
: (dat$ (date))
-> "20070601"
: (dat$ (date) "-")
-> "2007-06-01"
</code></pre>

<dt><a name="datStr"><code>(datStr 'dat ['flg]) -> sym</code></a>
<dd>Formats a <code><a href="refD.html#date">date</a></code> according to the
current <code><a href="refL.html#locale">locale</a></code>. If <code>flg</code>
is non-<code>NIL</code>, the year will be formatted modulo 100. See also
<code><a href="refD.html#dat$">dat$</a></code>, <code><a
href="refD.html#datSym">datSym</a></code>, <code><a
href="refS.html#strDat">strDat</a></code>, <code><a
href="refE.html#expDat">expDat</a></code>, <code><a
href="refE.html#expTel">expTel</a></code> and <code><a
href="refD.html#day">day</a></code>.

<p><pre><code>
: (datStr (date))
-> "2007-06-01"
: (locale "DE" "de")
-> NIL
: (datStr (date))
-> "01.06.2007"
: (datStr (date) T)
-> "01.06.07"
</code></pre>

<dt><a name="datSym"><code>(datSym 'dat) -> sym</code></a>
<dd>Formats a <code><a href="refD.html#date">date</a></code> <code>dat</code> in
in symbolic format (DDmmmYY). See also <code><a
href="refD.html#dat$">dat$</a></code> and <code><a
href="refD.html#datStr">datStr</a></code>.

<p><pre><code>
: (datSym (date))
-> "01jun07"
</code></pre>

<dt><a name="date"><code>(date ['T]) -> dat<br>
(date 'dat) -> (y m d)<br>
(date 'y 'm 'd) -> dat | NIL<br>
(date '(y m d)) -> dat | NIL</code></a>
<dd>Calculates a calendar date, represented as the number of days since first of
March in the year 0. When called without arguments, the current date is
returned. When called with a <code>T</code> argument, the current Coordinated
Universal Time (UTC) is returned. When called with a single number
<code>dat</code>, it is taken as a date and a list with the corresponding year,
month and day is returned. When called with three numbers (or a list of three
numbers) for the year, month and day, the corresponding date is returned (or
<code>NIL</code> if they do not represent a legal date). See also <code><a
href="refT.html#time">time</a></code>, <code><a
href="ref_.html#$dat">$dat</a></code>, <code><a
href="refD.html#dat$">dat$</a></code>, <code><a
href="refD.html#datSym">datSym</a></code>, <code><a
href="refD.html#datStr">datStr</a></code>, <code><a
href="refS.html#strDat">strDat</a></code>, <code><a
href="refE.html#expDat">expDat</a></code>, <code><a
href="refD.html#day">day</a></code>, <code><a
href="refW.html#week">week</a></code> and <code><a
href="refU.html#ultimo">ultimo</a></code>.

<p><pre><code>
: (date)                         # Today
-> 730589
: (date 2000 6 12)               # 12-06-2000
-> 730589
: (date 2000 22 5)               # Illegal date
-> NIL
: (date (date))                  # Today's year, month and day
-> (2000 6 12)
: (- (date) (date 2000 1 1))     # Number of days since first of January
-> 163
</code></pre>

<dt><a name="day"><code>(day 'dat ['lst]) -> sym</code></a>
<dd>Returns the name of the day for a given <code><a
href="refD.html#date">date</a></code> <code>dat</code>, in the language of the
current <code><a href="refL.html#locale">locale</a></code>. If <code>lst</code>
is given, it should be a list of alternative weekday names. See also <code><a
href="refW.html#week">week</a></code>, <code><a
href="refD.html#datStr">datStr</a></code> and <code><a
href="refS.html#strDat">strDat</a></code>.

<p><pre><code>
: (day (date))
-> "Friday"
: (locale "DE" "de")
-> NIL
: (day (date))
-> "Freitag"
: (day (date) '("Mo" "Tu" "We" "Th" "Fr" "Sa" "Su"))
-> "Fr"
</code></pre>

<dt><a name="db"><code>(db 'var 'cls ['hook] 'any ['var 'any ..]) -> sym</code></a>
<dd>Returns a database object of class <code>cls</code>, where the values for
the <code>var</code> arguments correspond to the <code>any</code> arguments.
<code>var</code>, <code>cls</code> and <code>hook</code> should specify a
<code><a href="refT.html#tree">tree</a></code> for <code>cls</code> or one of
its superclasses. See also <code><a href="refA.html#aux">aux</a></code>,
<code><a href="refC.html#collect">collect</a></code>, <code><a
href="refF.html#fetch">fetch</a></code>, <code><a
href="refI.html#init">init</a></code> and <code><a
href="refF.html#step">step</a></code>.

<p><pre><code>
: (db 'nr '+Item 1)
-> {3-1}
: (db 'nm '+Item "Main Part")
-> {3-1}
</code></pre>

<dt><a name="db:"><code>(db: cls ..) -> num</code></a>
<dd>Returns the database file number for objects of the type given by the
<code>cls</code> argument(s). Needed, for example, for the creation of <code><a
href="refN.html#new">new</a></code> objects. See also <code><a
href="refD.html#dbs">dbs</a></code>.

<p><pre><code>
: (db: +Item)
-> 3
</code></pre>

<dt><a name="dbck"><code>(dbck ['cnt] 'flg) -> any</code></a>
<dd>Performs a low-level integrity check of the current (or <code>cnt</code>'th)
database file, and returns <code>NIL</code> (or the number of blocks and symbols
if <code>flg</code> is non-<code>NIL</code>) if everything seems correct.
Otherwise, a string indicating an error is returned. As a side effect, possibly
unused blocks (as there might be when a <code><a
href="refR.html#rollback">rollback</a></code> is done before <code><a
href="refC.html#commit">commit</a></code>ing newly allocated (<code><a
href="refN.html#new">new</a></code>) external symbols) are appended to the free
list.

<p><pre><code>
: (pool "db")
-> T
: (dbck)
-> NIL
</code></pre>

<dt><a name="dbs"><code>(dbs . lst)</code></a>
<dd>Initializes the global variable <code><a
href="refD.html#*Dbs">*Dbs</a></code>. Each element in <code>lst</code> has a
number in its CAR (the block size scale factor of a database file, to be stored
in <code>*Dbs</code>). The CDR elements are either classes (so that objects of
that class are later stored in the corresponding file), or lists with a class in
the CARs and a list of relations in the CDRs (so that index trees for these
relations go into that file). See also <code><a
href="refD.html#dbs+">dbs+</a></code> and <code><a
href="refP.html#pool">pool</a></code>.

<p><pre><code>
(dbs
   (1 +Role +User)                              # (1 . 128)
   (2 +CuSu)                                    # (2 . 256)
   (1 +Item +Ord)                               # (3 . 128)
   (0 +Pos)                                     # (4 . 64)
   (2 (+Role nm) (+User nm))                    # (5 . 256)
   (3 (+CuSu nr nm str plz ort cty tel mob))    # (6 . 512)
   (3 (+Item nr nm sup pr))                     # (7 . 512)
   (3 (+Ord nr dat cus) (+Pos itm)) )           # (8 . 512)

: *Dbs
-> (1 2 1 0 2 3 3 3)
: (get '+Item 'dbf)
-> (3 . 128)
: (get '+Item 'nr 'dbf)
-> (7 . 512)
</code></pre>

<dt><a name="dbs+"><code>(dbs+ 'num . lst)</code></a>
<dd>Extends the list of database sizes stored in <code><a
href="refD.html#*Dbs">*Dbs</a></code>. <code>num</code> is the initial offset
into the list. See also <code><a href="refD.html#dbs">dbs</a></code>.

<p><pre><code>
(dbs+ 9
   (1 +NewCls)                                  # (9 . 128)
   (3 (+NewCls nr nm)) )                        # (10 . 512)
</code></pre>

<dt><a name="de"><code>(de sym . any) -> sym</code></a>
<dd>Assigns a definition to the <code>sym</code> argument, by setting its
<code>VAL</code> to the <code>any</code> argument. If the symbol has already
another value, a "redefined" message is issued. <code>de</code> is the standard
way to define a function. See also <code><a href="refD.html#def">def</a></code>,
<code><a href="refD.html#dm">dm</a></code> and <code><a
href="refU.html#undef">undef</a></code>.

<p><pre><code>
: (de foo (X Y) (* X (+ X Y)))  # Define a function
-> foo
: (foo 3 4)
-> 21

: (de *Var . 123)  # Define a variable value
: *Var
-> 123
</code></pre>

<dt><a name="debug"><code>(debug 'sym) -> T<br>
(debug 'sym 'cls) -> T<br>
(debug '(sym . cls)) -> T</code></a>
<dd>Inserts a <code><a href="ref_.html#!">!</a></code> breakpoint function call
at the beginning and all top-level expressions of the function or method body of
<code>sym</code>, to allow a stepwise execution. Typing <code>(d)</code> at a
breakpoint will also debug the current subexpression, and <code>(<a
href="refE.html#e">e</a>)</code> will evaluate the current subexpression. The
current subexpression is stored in the global variable <code><a
href="ref_.html#^">^</a></code>. See also <code><a
href="refD.html#*Dbg">*Dbg</a></code>, <code><a
href="refT.html#trace">trace</a></code> and <code><a
href="refL.html#lint">lint</a></code>.

<p><pre><code>
: (de tst (N)                    # Define tst
   (println (+ 3 N)) )
-> tst
: (debug 'tst)                   # Set breakpoints
-> T
: (pp 'tst)
(de tst (N)
   (! println (+ 3 N)) )         # Breakpoint '!'
-> tst
: (tst 7)                        # Execute
(println (+ 3 N))                # Stopped at beginning of 'tst'
! (d)                            # Debug subexpression
-> T
!                                # Continue
(+ 3 N)                          # Stopped in subexpression
! N                              # Inspect variable 'N'
-> 7
!                                # Continue
10                               # Output of print statement
-> 10                            # Done
: (unbug 'tst)
-> T
: (pp 'tst)                      # Restore to original
(de tst (N)
   (println (+ 3 N)) )
-> tst
</code></pre>

<dt><a name="dec"><code>(dec 'num) -> num<br>
(dec 'var ['num]) -> num</code></a>
<dd>The first form returns the value of <code>num</code> decremented by 1. The
second form decrements the <code>VAL</code> of <code>var</code> by 1, or by
<code>num</code>. <code>(dec 'num)</code> is equivalent to <code>(- 'num
1)</code> and <code>(dec 'var)</code> is equivalent to <code>(set 'var (- var
1))</code>.

<p><pre><code>
: (dec -1)
-> -2
: (dec 7)
-> 6
: (setq N 7)
-> 7
: (dec 'N)
-> 6
: (dec 'N 3)
-> 3
</code></pre>

<dt><a name="def"><code>(def 'sym 'any) -> sym<br>
(def 'sym 'sym 'any) -> sym</code></a>
<dd>The first form assigns a definition to the first <code>sym</code> argument,
by setting its <code>VAL</code>'s to <code>any</code>. The second form defines a
property value <code>any</code> for the second argument's <code>sym</code> key.
If any of these values existed and was changed in the process, a "redefined"
message is issued. See also <code><a href="refD.html#de">de</a></code> and
<code><a href="refD.html#dm">dm</a></code>.

<p><pre><code>
: (def 'b '((X Y) (* X (+ X Y))))
-> b
: (def 'b 999)
# b redefined
-> b
</code></pre>

<dt><a name="default"><code>(default sym 'any ..) -> any</code></a>
<dd>Stores new values <code>any</code> in the <code>sym</code> arguments only if
their current values are <code>NIL</code>. Otherwise, their values are left
unchanged. <code>default</code> is used typically in functions to initialize
optional arguments.

<p><pre><code>
: (de foo (A B)               # Function with two optional arguments
   (default  A 1  B 2)        # The default values are 1 and 2
   (list A B) )
-> foo
: (foo 333 444)               # Called with two arguments
-> (333 444)
: (foo 333)                   # Called with one arguments
-> (333 2)
: (foo)                       # Called without arguments
-> (1 2)
</code></pre>

<dt><a name="del"><code>(del 'any 'var) -> any</code></a>
<dd>Deletes <code>any</code> from the list in the value of <code>var</code>.
<code>(del 'any 'var)</code> is equivalent to <code>(set 'var (delete 'any
var))</code>. See also <code><a href="refD.html#delete">delete</a></code>,
<code><a href="refC.html#cut">cut</a></code> and <code><a
href="refP.html#pop">pop</a></code>.

<p><pre><code>
: (setq S '((a b c) (d e f)))
-> ((a b c) (d e f))
: (del '(d e f) 'S)
-> ((a b c))
: (del 'b S)
-> (a c)
</code></pre>

<dt><a name="delete"><code>(delete 'any 'lst) -> lst</code></a>
<dd>Deletes <code>any</code> from <code>lst</code>. If <code>any</code> is
contained more than once in <code>lst</code>, only the first occurrence is
deleted. See also <code><a href="refD.html#delq">delq</a></code>, <code><a
href="refR.html#remove">remove</a></code> and <code><a
href="refI.html#insert">insert</a></code>.

<p><pre><code>
: (delete 2 (1 2 3))
-> (1 3)
: (delete (3 4) '((1 2) (3 4) (5 6) (3 4)))
-> ((1 2) (5 6) (3 4))
</code></pre>

<dt><a name="delq"><code>(delq 'any 'lst) -> lst</code></a>
<dd>Deletes <code>any</code> from <code>lst</code>. If <code>any</code> is
contained more than once in <code>lst</code>, only the first occurrence is
deleted. <code><a href="ref_.html#==">==</a></code> is used for comparison
(pointer equality). See also <code><a href="refD.html#delete">delete</a></code>,
<code><a href="refA.html#asoq">asoq</a></code>, <code><a
href="refM.html#memq">memq</a></code> and <code><a
href="refM.html#mmeq">mmeq</a></code>.

<p><pre><code>
: (delq 'b '(a b c))
-> (a c)
: (delq 2 (1 2 3))
-> (1 2 3)
</code></pre>

<dt><a name="die"><code>(die 'cnt . prg) -> any</code></a>
<dd> If the execution of <code>prg</code> does not finish within
<code>cnt</code> seconds, the current process will receive a SIGTERM signal. See
also <code><a href="refB.html#bye">bye</a></code> and <code><a
href="refP.html#protect">protect</a></code>.

<p><pre><code>
: (die 6 (finally (msg 'Bye) (loop)))
Bye
$
</code></pre>

<dt><a name="diff"><code>(diff 'lst 'lst) -> lst</code></a>
<dd>Returns the difference of the <code>lst</code> arguments. See also <code><a
href="refS.html#sect">sect</a></code>.

<p><pre><code>
: (diff (1 2 3 4 5) (2 4))
-> (1 3 5)
: (diff (1 2 3) (1 2 3))
-> NIL
</code></pre>

<dt><a name="dir"><code>(dir ['any]) -> lst</code></a>
<dd>Returns a list of all filenames in the directory <code>any</code>. Names
starting with a dot '<code>.</code>' are ignored. See also <code><a
href="refC.html#cd">cd</a></code> and <code><a
href="refI.html#info">info</a></code>.

<p><pre><code>
: (filter '((F) (tail '(. c) (chop F))) (dir "src/"))
-> ("main.c" "subr.c" "gc.c" "io.c" "big.c" "sym.c" "tab.c" "flow.c" ..
</code></pre>

<dt><a name="dirname"><code>(dirname 'any) -> sym</code></a>
<dd>Returns the directory part of a path name <code>any</code>.
See also <code><a href="refP.html#path">path</a></code>.

<p><pre><code>
: (dirname "a/b/c/d")
-> "a/b/c"
</code></pre>

<dt><a name="dm"><code>(dm sym . fun) -> sym<br>
(dm (sym . cls) . fun) -> sym<br>
(dm (sym sym [. cls]) . fun) -> sym</code></a>
<dd>Defines a method for the message <code>sym</code> in the current class,
implicitly given by the value of the global variable <code><a
href="refC.html#*Class">*Class</a></code>, or - in the second form - for the
explicitly given class <code>cls</code>. In the third form, the class object is
obtained by <code><a href="refG.html#get">get</a></code>ing <code>sym</code>
from <code><a href="refC.html#*Class">*Class</a></code> (or <code>cls</code> if
given). See also <code><a href="ref.html#oop">OO Concepts</a></code>, <code><a
href="refD.html#de">de</a></code>, <code><a
href="refU.html#undef">undef</a></code>, <a href="refC.html#class">class</a>, <a
href="refR.html#rel">rel</a>, <a href="refV.html#var">var</a>, <a
href="refM.html#method">method</a>, <a href="refS.html#send">send</a> and <a
href="refT.html#try">try</a>.

<p><pre><code>
: (dm start> ()
   (super)
   (mapc 'start> (: fields))
   (mapc 'start> (: arrays)) )
</code></pre>

<dt><a name="do"><code>(do 'flg|num ['any | (NIL 'any . prg) | (T 'any . prg) ..]) -> any</code></a>
<dd>Counted loop with multiple conditional exits: The body is executed at most
<code>num</code> times (or never (if the first argument is <code>NIL</code>), or
an infinite number of times (if the first argument is <code>T</code>)). If a
clause has <code>NIL</code> or <code>T</code> as its <code>CAR</code>, the
clause's second element is evaluated as a condition and - if the result is
<code>NIL</code> or non-<code>NIL</code>, respectively - the <code>prg</code> is
executed and the result returned. Otherwise (if count drops to zero), the result
of the last expression is returned. See also <code><a
href="refL.html#loop">loop</a></code> and <code><a
href="refF.html#for">for</a></code>.

<p><pre><code>
: (do 4 (printsp 'Ok))
Ok Ok Ok Ok -> Ok
: (do 4 (printsp 'Ok) (T (= 3 3) (printsp 'done)))
Ok done -> done
</code></pre>

</dl>

</body>
</html>
