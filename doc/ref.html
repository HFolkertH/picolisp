<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Pico Lisp Reference</title>
<link rel="stylesheet" href="doc.css" type="text/css">
</head>
<body>
<a href="mailto:abu@software-lab.de">abu@software-lab.de</a>

<p align=right>
<i>Perfection is attained</i><br>
<i>not when there is nothing left to add</i><br>
<i>but when there is nothing left to take away</i><br>
<i>(Antoine de Saint-Exup√©ry)</i><br>


<h1>The Pico Lisp Reference</h1>

<p align=right>(c) Software Lab. Alexander Burger

<p>This document describes the concepts, data types, and kernel functions of the
<a href="http://software-lab.de/down.html">Pico Lisp</a> system.

<p>This is <i>not</i> a Lisp tutorial. For an introduction to Lisp, a
traditional Lisp book like "Lisp" by Winston/Horn (Addison-Wesley 1981) is
recommended. Note, however, that there are significant differences between Pico
Lisp and Maclisp (and even greater differences to Common Lisp).

<p>Please take a look at the <a href="tut.html">Pico Lisp Tutorial</a> for an
explanation of some aspects of Pico Lisp, and scan through the list of <a
href="faq.html">Frequently Asked Questions (FAQ)</a>.

<p><ul>
<li><a href="#intro">Introduction</a>
<li><a href="#vm">The Pico Lisp Machine</a>
   <ul>
   <li><a href="#cell">The Cell</a>
   <li><a href="#data">Data Types</a>
      <ul>
      <li><a href="#number">Numbers</a>
      <li><a href="#symbol">Symbols</a>
         <ul>
         <li><a href="#nilSym">NIL</a>
         <li><a href="#internal">Internal Symbols</a>
         <li><a href="#transient">Transient Symbols</a>
         <li><a href="#external">External Symbols</a>
         </ul>
      <li><a href="#lst">Lists</a>
      </ul>
   <li><a href="#mem">Memory Management</a>
   </ul>
<li><a href="#penv">Programming Environment</a>
   <ul>
   <li><a href="#invoc">Invocation</a>
   <li><a href="#io">Input/Output</a>
      <ul>
      <li><a href="#num-io">Numbers</a>
      <li><a href="#sym-io">Symbols</a>
         <ul>
         <li><a href="#nilSym-io">NIL</a>
         <li><a href="#internal-io">Internal Symbols</a>
         <li><a href="#transient-io">Transient Symbols</a>
         <li><a href="#external-io">External Symbols</a>
         </ul>
      <li><a href="#lst-io">Lists</a>
      <li><a href="#macro-io">Read-Macros</a>
      </ul>
   <li><a href="#ev">Evaluation</a>
   <li><a href="#int">Interrupt</a>
   <li><a href="#errors">Error Handling</a>
   <li><a href="#atres">@ Result</a>
   <li><a href="#cmp">Comparing</a>
   <li><a href="#oop">OO Concepts</a>
   <li><a href="#dbase">Database</a>
   <li><a href="#pilog">Pico Lisp Prolog</a>
   <li><a href="#conv">Naming Conventions</a>
   <li><a href="#trad">Breaking Traditions</a>
   </ul>
<li><a href="#foo">Function Reference</a>
<li><a href="#down">Download</a>
</ul>


<p><hr>
<h2><a name="intro">Introduction</a></h2>

<p>Pico Lisp is the result of a language design study, trying to answer the
question "What is a minimal but useful architecture for a virtual machine?".
Because opinions differ about what is meant by "minimal" and "useful", there are
many answers to that question, and people might consider other solutions more
"minimal" or more "useful". But from a practical point of view, Pico Lisp proved
to be a valuable answer to that question.

<p>First of all, Pico Lisp is a virtual machine architecture, and then a
programming language. It was designed in a "bottom up" way, and "bottom up" is
also the most natural way to understand and to use it: <i>Form Follows
Function</i>.

<p>Pico Lisp was used in several commercial and research programming projects
since 1988. Its internal structures are simple enough, allowing an experienced
programmer always to fully understand what's going on under the hood, and its
language features, efficiency and extensibility make it suitable for almost any
practical programming task.

<p>In a nutshell, emphasis was put on four design objectives. The Pico Lisp
system should be

<p><dl>

<dt>Simple
<dd>The internal data structure should be as simple as possible. Only one single
data structure is used to build all higher level constructs.

<dt>Unlimited
<dd>There are no limits imposed upon the language due to limitations of the
virtual machine architecture. That is, there is no upper bound in symbol name
length, number digit counts, stack depth, or data structure and buffer sizes,
except for the total memory size of the host machine.

<dt>Dynamic
<dd>Behavior should be as dynamic as possible ("run"-time vs. "compile"-time).
All decisions are delayed till runtime where possible. This involves matters
like memory management, dynamic symbol binding, and late method binding.

<dt>Practical
<dd>Pico Lisp is not just a toy of theoretical value. It is used since 1988 in
actual application development, research and production.

</dl>


<p><hr>
<h2><a name="vm">The Pico Lisp Machine</a></h2>

<p>An important point in the Pico Lisp philosophy is the knowledge about the
architecture and data structures of the internal machinery. The high-level
constructs of the programming language directly map to that machinery, making
the whole system both understandable and predictable.

<p>This is similar to assembly language programming, where the programmer has
complete control over the machine.


<p><hr>
<h3><a name="cell">The Cell</a></h3>

<p>The Pico Lisp virtual machine is both simpler and more powerful than most
current (hardware) processors. At the lowest level, it is constructed from a
single data structure called "cell":

<p><pre><code>
         +-----+-----+
         | CAR | CDR |
         +-----+-----+
</code></pre>

<p>A cell is a pair of machine words, which traditionally are called
<code>CAR</code> and <code>CDR</code> in the Lisp terminology. These words can
represent either a numeric value (scalar) or the address of another cell
(pointer). All higher level data structures are built out of cells.

<p>The type information of higher level data is contained in the pointers to
these data. Assuming the implementation on a byte-addressed physical machine,
and a pointer size of typically 4 bytes, each cell has a size of 8 bytes.
Therefore, the pointer to a cell must point to an 8-byte boundary, and its
bit-representation will look like:

<p><pre><code>
      xxxxxxxxxxxxxxxxxxxxxxxxxxxxx000
</code></pre>

<p>(the <code>'x'</code> means "don't care"). For the individual data types, the
pointer is adjusted to point to other parts of a cell, in effect setting some of
the lower three bits to non-zero values. These bits are then used by the
interpreter to determine the data type.

<p>In any case, bit(0) - the least significant of these bits - is reserved as a
mark bit for garbage collection.

<p>Initially, all cells in the memory are unused (free), and linked together to
form a "free list". To create higher level data types at runtime, cells are
taken from that free list, and returned by the garbage collector when they are
no longer needed. All memory management is done via that free list; there are no
additional buffers, string spaces or special memory areas (With two exceptions:
A certain fixed area of memory is set aside to contain the executable code and
global variables of the interpreter itself, and a standard push down stack for
return addresses and temporary storage. Both are not directly accessible by the
programmer).


<p><hr>
<h3><a name="data">Data Types</a></h3>

<p>On the virtual machine level, Pico Lisp supports

<p><ul>
<li>three base data types: Numbers, Symbols and Cons Pairs (Lists)
<li>the three scope variations of symbols: Internal, Transient and External
<li>and the special symbol <code>NIL</code>.
</ul>

<p>They are all built from the single cell data structure, and all runtime data
cannot consist of any other types than these three.

<p>The following diagram shows the complete data type hierarchy, consisting of
the three base types and the symbol variations:

<p><pre><code>
                    cell
                     |
            +--------+--------+
            |        |        |
         Number    Symbol    List
                     |
                     |
   +--------+--------+--------+
   |        |        |        |
  NIL   Internal Transient External
</code></pre>


<p><hr>
<h4><a name="number">Numbers</a></h4>

<p>A number can represent a signed integral value of arbitrary size. The
<code>CAR</code>s of one or more cells hold the number's "digits" (each in the
machine's word size), to store the number's binary representation.

<p><pre><code>
         Number
         |
         V
      +-----+-----+     +-----+-----+     +-----+-----+
      |'DIG'|  ---+---> |'DIG'|  ---+---> |'DIG'|  /  |
      +-----+-----+     +-----+-----+     +-----+-----+
</code></pre>

<p>The first cell holds the least significant digit. The least significant bit
of that digit represents the sign.

<p>The pointer to a number points into the middle of the <code>CAR</code>, with
an offset of 2 from the cell's start address. Therefore, the bit pattern of a
number will be:

<p><pre><code>
      xxxxxxxxxxxxxxxxxxxxxxxxxxxxx010
</code></pre>

<p>Thus, a number is recognized by the interpreter when bit(1) is non-zero.


<p><hr>
<h4><a name="symbol">Symbols</a></h4>

<p>A symbol is more complex than a number. Each symbol has a value, and
optionally a name and an arbitrary number of properties. The <code>CAR</code> of
a symbol cell is also called <code>VAL</code>, and the <code>CDR</code> points
to the symbol's tail. As a minimum, a symbol consists of a single cell, and has
no name or properties:

<p><pre><code>
            Symbol
            |
            V
      +-----+-----+
      | VAL |  /  |
      +-----+-----+
</code></pre>

<p>That is, the symbol's tail is empty (points to <code>NIL</code>, as indicated
by the '/' character).

<p>The pointer to a symbol points to the <code>CDR</code> of the cell, with an
offset of 4 from the cell's start address. Therefore, the bit pattern of a
symbol will be:

<p><pre><code>
      xxxxxxxxxxxxxxxxxxxxxxxxxxxxx100
</code></pre>

<p>Thus, a symbol is recognized by the interpreter when bit(2) is non-zero. In
addition, it is possible that bit(1) is also set for a symbol (This is the case
for external symbols).

<p>A property is a key-value-pair, represented as a cell in the symbol's tail.
This is called a "property list". The property list may be terminated by a
number representing the symbol's name. In the following example, a symbol with
the name <code>"abc"</code> has three properties:

<p><pre><code>
            Symbol
            |
            V
      +-----+-----+
      | VAL |  ---+---+
      +-----+-----+   | tail
                      |
         +------------+
         |
         V                                                      name
         +-----+-----+     +-----+-----+     +-----+-----+     +-----+-----+
         |  |  |  ---+---> | KEY |  ---+---> |  |  |  ---+---> |'cba'|  /  |
         +--+--+-----+     +-----+-----+     +--+--+-----+     +-----+-----+
            |                                   |
            V                                   V
            +-----+-----+                       +-----+-----+
            | VAL | KEY |                       | VAL | KEY |
            +-----+-----+                       +-----+-----+
</code></pre>

<p>Each property in a symbol's tail is either a symbol (then it represents a
boolean value), or a cell with the property key in its <code>CDR</code> and the
property value in its <code>CAR</code>. In both cases, the key should be a
symbol, because searches in the property list are performed using pointer
comparisons.

<p>The name of a symbol is stored as a number at the end of the tail. It
contains the characters of the name in UTF-8 encoding, using between one and
three 8-bit-bytes per character. The first byte of the first character is stored
in the lowest 8 bits of the number.

<p>All symbols have the above structure, but depending on scope and
accessibility there are actually four types of symbols: <code><a
href="#nilSym">NIL</a></code>, <a href="#internal">internal</a>, <a
href="#transient">transient</a> and <a href="#external">external</a> symbols.


<p><hr>
<h5><a name="nilSym">NIL</a></h5>

<p><code>NIL</code> is a special symbol which exists exactly once in the whole
system. It is used

<p><ul>
<li>as an end-of-list marker
<li>to represent the empty list
<li>to represent the boolean value "false"
<li>to represent a string of length zero
<li>to represent the value "Not a Number"
<li>as the root of all class hierarchies
</ul>

<p>For that, <code>NIL</code> has a special structure:

<p><pre><code>
      NIL:  /
            |
            V
      +-----+-----+-----+-----+
      |  /  |  /  |  /  |  /  |
      +-----+--+--+-----+-----+
</code></pre>

<p>The reason for that structure is <code>NIL</code>'s dual nature both as a
symbol and as a list:

<p><ul>
<li>As a symbol, it should give <code>NIL</code> for its <code>VAL</code>, and
be without properties

<li>For the empty list, <code>NIL</code> should give <code>NIL</code> both for
its <code>CAR</code> and for its <code>CDR</code>

</ul>

<p>These requirements are fulfilled by the above structure.


<p><hr>
<h5><a name="internal">Internal Symbols</a></h5>

<p>Internal Symbols are all those "normal" symbols, as they are used for
function definitions and variable names. They are "interned" into a hashed list
structure, so that it is possible to find an internal symbol by searching for
its name.

<p>There cannot be two different internal symbols with the same name.

<p>Initially, a new internal symbol's <code>VAL</code> is <code>NIL</code>.


<p><hr>
<h5><a name="transient">Transient Symbols</a></h5>

<p>Transient symbols are only interned into a hashed list structure for a
certain time (e.g. while reading the current source file), and are released
after that. That means, a transient symbol cannot be accessed then by its name,
and there may be several transient symbols in the system having the same name.

<p>Transient symbols are used

<p><ul>
<li>as text strings

<li>as identifiers with a limited access scope (like, for example,
<code>static</code> identifiers in the <code>C</code> language family)

<li>as anonymous, dynamically created objects (without a name)

</ul>

<p>Initially, a new transient symbol's <code>VAL</code> is that symbol itself.

<p>A transient symbol without a name can be created with the <code><a
href="#box">box</a></code> or <code><a href="#new">new</a></code> functions.


<p><hr>
<h5><a name="external">External Symbols</a></h5>

<p>External symbols reside in a database file, and are loaded into memory - and
written back to the file - dynamically as needed, and transparent to the
programmer.

<p>The interpreter recognizes external symbols, because in addition to the
symbol bit(2), also bit(1) is set:

<p><pre><code>
      xxxxxxxxxxxxxxxxxxxxxxxxxxxxx110
</code></pre>

<p>There cannot be two different external symbols with the same name. External
symbols are maintained in hash structures while they are loaded into memory, and
have their external location (disk block, network URL, etc.) directly coded into
their names.

<p>Initially, a new external symbol's <code>VAL</code> is <code>NIL</code>,
unless otherwise specified at creation time.


<p><hr>
<h4><a name="lst">Lists</a></h4>

<p>A list is a sequence of one or more cells, holding numbers, symbols, or
lists. Lists are used in Pico Lisp to emulate composite data structures like
arrays, trees, stacks or queues.

<p>In contrast to lists, numbers and symbols are collectively called "Atoms".

<p>Typically, the <code>CDR</code> of each cell in a list points to the
following cell, except for the last cell which points <code>NIL</code>. If,
however, the <code>CDR</code> of the last cell points to an atom, that cell is
called a "dotted pair" (because of its I/O syntax with a dot '.' between the two
values).


<p><hr>
<h3><a name="mem">Memory Management</a></h3>

<p>The Pico Lisp interpreter has complete knowledge of all data in the system,
due to the type information associated with every pointer. Therefore, an
efficient garbage collector mechanism can easily be implemented. Pico Lisp
employs a simple but fast mark-and-sweep garbage collector.

<p>As the collection process is very fast (in the order of milliseconds per
megabyte), it was not necessary to develop more complicated, time-consuming and
error-prone garbage collection algorithms (e.g. incremental collection). A
compacting garbage collector is also not necessary, because the single cell data
type cannot cause heap fragmentation.


<p><hr>
<h2><a name="penv">Programming Environment</a></h2>

<p>Lisp was chosen as the programming language, because of its clear and simple
structure.

<p>In some previous versions, a Forth-like syntax was also implemented on top of
a similar virtual machine (Lifo). Though that language was more flexible and
expressive, the traditional Lisp syntax proved easier to handle, and the virtual
machine can be kept considerably simpler.

Pico Lisp inherits the major advantages of classical Lisp systems like

<p><ul>
<li>Dynamic data types and structures
<li>Formal equivalence of code and data
<li>Functional programming style
<li>An interactive environment
</ul>

<p>In the following, some concepts and peculiarities of the Pico Lisp language
and environment are described.


<p><hr>
<h3><a name="invoc">Invocation</a></h3>

<p>When Pico Lisp is invoked from the command line, an arbitrary number of
arguments may follow the command name.

<p>By default, each argument is the name of a file to be executed by the
interpreter. If, however, the argument's first character is a hyphen '-', then
the rest of that argument is taken as a function call (without the surrounding
parentheses). A hyphen by itself as an argument stops evaluation of the rest of
the command line (it may be processed later using the <code><a
href="#argv">argv</a></code> function). This mechanism corresponds to calling
<code>(<a href="#load">load</a> T)</code>.

<p>As a convention, Pico Lisp source files have the extension "<code>.l</code>".

<p>Note that the Pico Lisp executable itself does not expect or accept any
command line flags or options. They are reserved for application programs.

<p>The simplest and shortest invocation of Pico Lisp does nothing, and exits
immediately by calling <code><a href="#bye">bye</a></code>:

<p><pre><code>
$ bin/picolisp -bye
$
</code></pre>

<p>In interactive mode, the Pico Lisp interpreter (see <code><a
href="#load">load</a></code>) will also exit when an empty line is entered:

<p><pre><code>
$ bin/picolisp
:                       # Typed RETURN
$
</code></pre>

<p>To start up the standard Pico Lisp environment, several files should be
loaded. The most commonly used things are in "lib.l" and in a bunch of other
files, which are in turn loaded by "ext.l". Thus, a typical call would be:

<p><pre><code>
$ bin/picolisp lib.l ext.l
</code></pre>

<p>The recommended way, however, is to call the "p" shell script, which includes
"lib.l" and "ext.l". Given that your current project is loaded by some file
"myProject.l" and your startup function is <code>main</code>, your invocation
would look like:

<p><pre><code>
$ ./p myProject.l -main
</code></pre>

<p>For interactive development and debugging it is recommended also to load
"dbg.l", to get the vi-style command line editor, single-stepping, tracing and
other debugging utilities.

<p><pre><code>
$ ./p dbg.l myProject.l -main
</code></pre>

<p>In any case, the directory part of the first file name supplied on the
command line is remembered internally as the <u>Pico Lisp Home Directory</u>.
This path is later automatically substituted for any leading "<code>@</code>"
character in file name arguments to I/O functions (see <code><a
href="#path">path</a></code>).


<p><hr>
<h3><a name="io">Input/Output</a></h3>

<p>In Lisp, each internal data structure has a well-defined external
representation in human-readable format. All kinds of data can be written to a
file, and restored later to their original form by reading that file.

<p>In normal operation, the Pico Lisp interpreter continuously executes an
infinite "read-eval-print loop". It reads one expression at a time, evaluates
it, and prints the result to the console. Any input into the system, like data
structures and function definitions, is done in a consistent way no matter
whether it is entered at the console or read from a file.

<p>Comments can be embedded in the input stream with the hash <code>#</code>
character. Everything up to the end of that line will be ignored by the reader.

<p><pre><code>
: (* 1 2 3)  # This is a comment
-> 6
</code></pre>

<p>Here is the I/O syntax for the individual Pico Lisp data types:


<p><hr>
<h4><a name="num-io">Numbers</a></h4>

<p>A number consists of an arbitrary number of digits (<code>'0'</code> through
<code>'9'</code>), optionally preceded by a sign character (<code>'+'</code> or
<code>'-'</code>). Legal number input is:

<p><pre><code>
: 7
-> 7
: -12345678901245678901234567890
-> -12345678901245678901234567890
</code></pre>

<p>Fixed-point numbers can be input by embedding a decimal point
<code>'.'</code>, and setting the global variable <code><a
href="#*Scl">*Scl</a></code> appropriately:

<p><pre><code>
: *Scl
-> 0

: 123.45
-> 123
: 456.78
-> 457

: (setq *Scl 3)
-> 3
: 123.45
-> 123450
: 456.78
-> 456780
</code></pre>

<p>Thus, fixed-point input simply scales the number to an integer value
corresponding to the number of digits in <code><a href="#*Scl">*Scl</a></code>.

<p>Formatted output of scaled fixed-point values can be done with the <code><a
href="#format">format</a></code> function:

<p><pre><code>
: (format 1234567890 2)
-> "12345678.90"
: (format 1234567890 2 "." ",")
-> "12,345,678.90"
</code></pre>


<p><hr>
<h4><a name="sym-io">Symbols</a></h4>

<p>The reader is able to recognize the individual symbol types from their
syntactic form. A symbol name should - of course - not look like a legal number
(see above).

<p>In general, symbol names are case-sensitive. <code>car</code> is not the same
as <code>CAR</code>.


<p><hr>
<h5><a name="nilSym-io">NIL</a></h5>

<p>Besides for standard normal form, <code>NIL</code> is also recognized as
<code>()</code>, <code>[]</code> or <code>""</code>.

<p><pre><code>
: NIL
-> NIL
: ()
-> NIL
: ""
-> NIL
</code></pre>

<p>Output will always appear as <code>NIL</code>.


<p><hr>
<h5><a name="internal-io">Internal Symbols</a></h5>

<p>Internal symbol names can consist of any printable (non-whitespace)
character, except for the following meta characters:

<p><pre><code>
   "  '  (  )  [  ]  `  ~
</code></pre>

<p>As a rule, anything not recognized by the reader as another data type will be
returned as an internal symbol.


<p><hr>
<h5><a name="transient-io">Transient Symbols</a></h5>

<p>A transient symbol is anything surrounded by double quotes '<code>"</code>'.
With that, it looks - and can be used - like a string constant in other
languages. However, it is a real symbol, and may be assigned a value or a
function definition, and properties.

<p>Initially, a transient symbol's value is that symbol itself, so that it does
not need to be quoted for evaluation:

<p><pre><code>
: "This is a string"
-> "This is a string"
</code></pre>

<p>However, care must be taken when assigning a value to a transient symbol.
This may cause unexpected behavior:

<p><pre><code>
: (setq "This is a string" 12345)
-> 12345
: "This is a string"
-> 12345
</code></pre>

<p>The name of a transient symbol can contain any character. A double quote
character can be escaped with a backslash '<code>\</code>', and a backslash
itself has to be escaped with another backslash. Control characters can be
written with a preceding hat '<code>^</code>' character.

<p><pre><code>
: "We^Ird\\Str\"ing"
-> "We^Ird\\Str\"ing"
: (chop @)
-> ("W" "e" "^I" "r" "d" "\\" "S" "t" "r" "\"" "i" "n" "g")
</code></pre>

<p>The hash table for transient symbols is cleared automatically before and
after <code><a href="#load">load</a></code>ing a source file, or it can be reset
explicitly with the <code><a href="#====">====</a></code> function. With that
mechanism, it is possible to create symbols with a local access scope, not
accessible from other parts of the program.

<p>A special case of transient symbols are <i>anonymous symbols</i>. These are
symbols without name (see <code><a href="#box">box</a></code>, <code><a
href="#boxQ">box?</a></code> or <code><a href="#new">new</a></code>). They print
as a dollar sign (<code>$</code>) followed by a decimal digit string (actually
their machine address).


<p><hr>
<h5><a name="external-io">External Symbols</a></h5>

<p>External symbol names are surrounded by braces (<code>'{'</code> and
<code>'}'</code>). The characters of the symbol's name itself identify the
physical location of the external object. This is currently the number of the
starting block in the database file, encoded in base-64 notation (characters
'<code>0</code>' through '<code>9</code>', '<code>:</code>' through
'<code>;</code>', '<code>A</code>' through '<code>Z</code>' and '<code>a</code>'
through '<code>z</code>'). Later versions might include other formats like
Internet URL's.


<p><hr>
<h4><a name="lst-io">Lists</a></h4>

<p>Lists are surrounded by parentheses (<code>'('</code> and <code>')'</code>).

<p><code>(A)</code> is a list consisting of a single cell, with the symbol
<code>A</code> in its <code>CAR</code>, and <code>NIL</code> in its
<code>CDR</code>.

<p><code>(A B C)</code> is a list consisting of three cells, with the symbols
<code>A</code>, <code>B</code> and <code>C</code> respectively in their
<code>CAR</code>, and <code>NIL</code> in the last cell's <code>CDR</code>.

<p><code>(A . B)</code> is a "dotted pair", a list consisting of a single cell,
with the symbol <code>A</code> in its <code>CAR</code>, and <code>B</code> in
its <code>CDR</code>.

<p>Pico Lisp has built-in support for reading and printing simple circular
lists. If the dot in a dotted-pair notation is immediately followed by a closing
parenthesis, it indicates that the <code>CDR</code> of the last cell points back
to the beginning of that list.

<p><pre><code>
: (let L '(a b c) (conc L L))
-> (a b c .)
: (cdr '(a b c .))
-> (b c a .)
: (cddddr '(a b c .))
-> (b c a .)
</code></pre>

<p>A similar result can be achieved with the function <code><a
href="#circ">circ</a></code>. Such lists must be used with care, because many
functions won't terminate or will crash when given such a list.


<p><hr>
<h4><a name="macro-io">Read-Macros</a></h4>

<p>Read-macros in Pico Lisp are special forms that are recognized by the reader,
and modify its behavior. Note that they take effect immediately while reading an
expression, and are not seen by the <code>eval</code> in the main loop.

<p>The most prominent read-macro in Lisp is the single quote character
<code>'</code>, which expands to a call of the <code><a
href="#quote">quote</a></code> function. Note that the single quote character is
also printed instead of the full function name.

<p><pre><code>
: '(a b c)
-> (a b c)
: '(quote . a)
-> 'a
: (cons 'quote 'a)   # (quote . a)
-> 'a
: (list 'quote 'a)   # (quote a)
-> '(a)
</code></pre>

<p>A comma (<code>,</code>) will cause the reader to collect the following data
item into the global variable <code><a href="#*Uni">*Uni</a></code>, and to
return a previously inserted equal item if present. This makes it possible to
create a unique list of references to data which do normally not follow the
rules of pointer equality.

<p>A single backquote character <code>`</code> will cause the reader to evaluate
the following expression, and return the result.

<p><pre><code>
: '(a `(+ 1 2 3) z)
-> (a 6 z)
</code></pre>

<p>A tilde character <code>~</code> inside a list will cause the reader to
evaluate the following expression, and splice the result into the list.

<p><pre><code>
: '(a b c ~(list 'd 'e 'f) g h i)
-> (a b c d e f g h i)
</code></pre>

<p>Brackets (<code>'['</code> and <code>']'</code>) can be used as super
parentheses. A closing bracket will match the innermost opening bracket, or all
currently open parentheses.

<p><pre><code>
: '(a (b (c (d]
-> (a (b (c (d))))
: '(a (b [c (d]))
-> (a (b (c (d))))
</code></pre>

<p>Finally, reading the sequence '<code>{}</code>' will result in a new
anonymous symbol with value <code>NIL</code>, equivalent to a call to <code><a
href="#box">box</a></code> without arguments.

<p><pre><code>
: '({} {} {})
-> ($134599965 $134599967 $134599969)
: (mapcar val @)
-> (NIL NIL NIL)
</code></pre>


<p><hr>
<h3><a name="ev">Evaluation</a></h3>

<p>Pico Lisp tries to evaluate any expression encountered in the read-eval-print
loop. Basically, it does so by applying the following three rules:

<p><ul>
<li>A number evaluates to itself.

<li>A symbol evaluates to its value (<code>VAL</code>).

<li>A list is evaluated as a function call, with the <code>CAR</code> as the
function and the <code>CDR</code> the arguments to that function. These
arguments are in turn evaluated according to these three rules.

</ul>

<p><pre><code>
: 1234
-> 1234        # Number evaluates to itself
: *Pid
-> 22972       # Symbol evaluates to its VAL
: (+ 1 2 3)
-> 6           # List is evaluated as a function call
</code></pre>

<p>For the third rule, however, things get a bit more involved. First - as a
special case - if the <code>CAR</code> of the list is a number, the whole list
is returned as it is:

<p><pre><code>
: (1 2 3 4 5 6)
-> (1 2 3 4 5 6)
</code></pre>

<p>This is not really a function call but just a convenience to avoid having to
quote simple data lists.

<p>Otherwise, if the <code>CAR</code> is a symbol or a list, Pico Lisp tries to
obtain an executable function from that, by either using the symbol's value, or
by evaluating the list.

<p>What is an executable function? Or, said in another way, what can be applied
to a list of arguments, to result in a function call? A legal function in Pico
Lisp is

<p><dl>
<dt>either
<dd>a <u>number</u>. When a number is used as a function, it is simply taken as
a pointer to executable code that will be called with the list of (unevaluated)
arguments as its single parameter. It is up to that code to evaluate the
arguments, or not. Some functions do not evaluate their arguments (e.g.
<code>quote</code>) or evaluate only some of their arguments (e.g.
<code>setq</code>).

<dt>or
<dd>a <u>lambda expression</u>. A lambda expression is a list, whose
<code>CAR</code> is either a symbol or a list of symbols, and whose
<code>CDR</code> is a list of expressions. Note: In contrast to other Lisp
implementations, the symbol LAMBDA itself does not exist in Pico Lisp but is
implied from context.

</dl>

<p>A few examples should help to understand the practical consequences of these
rules. In the most common case, the <code>CAR</code> will be a symbol defined as
a function, like the <code>*</code> in:

<p><pre><code>
: (* 1 2 3)    # Call the function '*'
-> 6
</code></pre>

<p>Inspecting the <code>VAL</code> of <code>*</code>, however, gives

<p><pre><code>
: *            # Get the VAL of the symbol '*'
-> 67291944
</code></pre>

<p>The <code>VAL</code> of <code>*</code> is a number. In fact, it is the
numeric representation of a <code>C</code>-function pointer, i.e. a pointer to
executable code. This is the case for all built-in functions of Pico Lisp.

<p>Other functions in turn are written as Lisp expressions:

<p><pre><code>
: (de foo (X Y)            # Define the function 'foo'
   (* (+ X Y) (+ X Y)) )
-> foo
: (foo 2 3)                # Call the function 'foo'
-> 25
: foo                      # Get the VAL of the symbol 'foo'
-> ((X Y) (* (+ X Y) (+ X Y)))
</code></pre>

<p>The <code>VAL</code> of <code>foo</code> is a list. It is the list that was
assigned to <code>foo</code> with the <code>de</code> function. It would be
perfectly legal to use <code>setq</code> instead of <code>de</code>:

<p><pre><code>
: (setq foo '((X Y) (* (+ X Y) (+ X Y))))
-> ((X Y) (* (+ X Y) (+ X Y)))
: (foo 2 3)
-> 25
</code></pre>

<p>If the <code>VAL</code> of <code>foo</code> were another symbol, that
symbol's <code>VAL</code> would be used instead to search for an executable
function.

<p>As we said above, if the <code>CAR</code> of the evaluated expression is not
a symbol but a list, that list is evaluated to obtain an executable function.

<p><pre><code>
: ((intern (pack "c" "a" "r")) (1 2 3))
-> 1
</code></pre>

<p>Here, the <code>intern</code> function returns the symbol <code>car</code>
whose <code>VAL</code> is used then. It is also legal, though quite dangerous,
to use the code-pointer directly:

<p><pre><code>
: car
-> 67306152
: ((* 2 33653076) (1 2 3))
-> 1
</code></pre>

<p>When an executable function is defined in Lisp itself, we call it a <a
name="lambda"><u>lambda expression</u></a>. A lambda expression always has a
list of executable expressions as its <code>CDR</code>. The <code>CAR</code>,
however, must be a either a list of symbols, or a single symbol, and it controls
the evaluation of the arguments to the executable function according to the
following rules:

<p><dl>

<dt>When the <code>CAR</code> is a list of symbols

<dd>For each of these symbols an argument is evaluated, then the symbols are
bound simultaneously to the results. The body of the lambda expression is
executed, then the <code>VAL</code>'s of the symbols are restored to their
original values. This is the most common case, a fixed number of arguments is
passed to the function.

<dt>Otherwise, when the <code>CAR</code> is the symbol <code>@</code> <dd>All
arguments are evaluated and the results kept internally in a list. The body of
the lambda expression is executed, and the evaluated arguments can be accessed
sequentially with the <code><a href="#args">args</a></code>, <code><a
href="#next">next</a></code>, <code><a href="#arg">arg</a></code> and <code><a
href="#rest">rest</a></code> functions. This allows to define functions with a
variable number of evaluated arguments.

<dt>Otherwise, when the <code>CAR</code> is a single symbol <dd>The symbol is
bound to the whole unevaluated argument list. The body of the lambda expression
is executed, then the symbol is restored to its original value. This allows to
define functions with unevaluated arguments. Any kind of interpretation and
evaluation of the argument list can be done inside the expression body.

</dl>

<p>In all cases, the return value is the result of the last expression in the
body.

<p><pre><code>
: (de foo (X Y Z)                   # CAR is a list of symbols
   (list X Y Z) )                   # Return a list of all arguments
-> foo
: (foo (+ 1 2) (+ 3 4) (+ 5 6))
-> (3 7 11)                         # all arguments are evaluated
</code></pre>

<p><pre><code>
: (de foo X                         # CAR is a single symbol
   X )                              # Return the argument
-> foo
: (foo (+ 1 2) (+ 3 4) (+ 5 6))
-> ((+ 1 2) (+ 3 4) (+ 5 6))        # the whole unevaluated list is returned
</code></pre>

<p><pre><code>
: (de foo @                         # CAR is the symbol '@'
   (list (next) (next) (next)) )    # Return the first three arguments
-> foo
: (foo (+ 1 2) (+ 3 4) (+ 5 6))
-> (3 7 11)                         # all arguments are evaluated
</code></pre>

<p>Note that these forms can also be combined. For example, to evaluate only the
first two arguments, bind the results to <code>X</code> and <code>Y</code>, and
bind all other arguments (unevaluated) to <code>Z</code>:

<p><pre><code>
: (de foo (X Y . Z)                 # CAR is a list with a dotted-pair tail
   (list X Y Z) )                   # Return a list of all arguments
-> foo
: (foo (+ 1 2) (+ 3 4) (+ 5 6))
-> (3 7 ((+ 5 6)))                  # two arguments are evaluated
</code></pre>

<p>Or, a single argument followed by a variable number of arguments:

<p><pre><code>
: (de foo (X . @)                   # CAR is a dotted-pair with '@'
   (println X)                      # print the first evaluated argument
   (while (args)                    # while there are more arguments
      (println (next)) ) )          # print the next one
-> foo
: (foo (+ 1 2) (+ 3 4) (+ 5 6))
3                                   # X
7                                   # Next arg
11
-> 11
</code></pre>


<p><hr>
<h3><a name="int">Interrupt</a></h3>

<p>During the evaluation of an expression, the Pico Lisp interpreter can be
interrupted at any time by hitting <code>Ctrl-C</code>. It will then enter the
breakpoint routine, as if <code><a href="#!">!</a></code> were called.

<p>Hitting <code>RETURN</code> at that point will continue evaluation, while
<code>(<a href="#quit">quit</a>)</code> will abort evaluation and return the
interpreter to the top level.

See also <code><a href="#debug">debug</a></code>, <code><a
href="#e">e</a></code>, <code><a href="#^">^</a></code> and <code><a
href="#*Dbg">*Dbg</a></code>


<p><hr>
<h3><a name="errors">Error Handling</a></h3>

<p>When a runtime error occurs, execution is stopped and an error handler is
entered.

<p>The error handler resets the I/O channels to the console, and displays the
location (if possible) and the reason of the error, followed by an error
message. That message is also stored in the global <code><a
href="#*Msg">*Msg</a></code>. If the <code>VAL</code> of the global <code><a
href="#*Err">*Err</a></code> is non-<code>NIL</code> it is executed as a
<code>prg</code> body. If the standard input is from a terminal, a
read-eval-print loop (with a question mark "<code>?</code>" as prompt) is
entered (the loop is exited when an empty line is input). Then all pending
<code><a href="#finally">finally</a></code> expressions are executed, all
variable bindings restored, and all files closed. If the standard input is not
from a terminal, the interpreter terminates. Otherwise it is reset to its
top-level state.

<p>If the <code>VAL</code> of the global <code><a href="#*Rst">*Rst</a></code>
is non-<code>NIL</code>, no interactive read-eval-print loop will be entered,
and that <code>VAL</code> will be executed instead - after the above cleanup was
done - as a <code>prg</code> body.

<p><pre><code>
: (de foo (A B) (badFoo A B))       # 'foo' calls an undefined symbol
-> foo
: (foo 3 4)                         # Call 'foo'
!? (badFoo A B)                     # Error handler entered
badFoo -- Undefined
? A                                 # Inspect 'A'
-> 3
? B                                 # Inspect 'B'
-> 4
?                                   # Empty line: Exit
:
</code></pre>


<p><hr>
<h3><a name="atres">@ Result</a></h3>

<p>In certain situations, the result of the last evaluation is stored in the
<code>VAL</code> of the symbol <code>@</code>. This can be very convenient,
because it often makes the assignment to temporary variables unnecessary.

<p><dl>

<dt><code><a href="#load">load</a></code> <dd>In read-eval loops, the last three
results which were printed at the console are available in <code>@@@</code>,
<code>@@</code> and <code>@</code>, in that order (i.e the latest result is in
<code>@</code>).

<p><pre><code>
: (+ 1 2 3)
-> 6
: (/ 128 4)
-> 32
: (- @ @@)        # Subtract the last two results
-> 26
</code></pre>

<p><dt>Flow functions
<dd>Flow- and logic-functions store the result of evaluating their conditional
expression in <code>@</code>.

<p><pre><code>
: (while (read) (println 'got: @))
abc            # User input
got: abc       # print result
123            # User input
got: 123       # print result
NIL
-> 123

: (setq L (1 2 3 4 5 1 2 3 4 5))
-> (1 2 3 4 5 1 2 3 4 5)
: (and (member 3 L) (member 3 (cdr @)) (set @ 999))
-> 999
: L
-> (1 2 3 4 5 1 2 999 4 5)
</code></pre>

<p>These functions include
   <a href="#and">and</a>,
   <a href="#case">case</a>,
   <a href="#cond">cond</a>,
   <a href="#nond">nond</a>,
   <a href="#do">do</a>,
   <a href="#for">for</a>,
   <a href="#if">if</a>,
   <a href="#if2">if2</a>,
   <a href="#ifn">ifn</a>,
   <a href="#loop">loop</a>,
   <a href="#nand">nand</a>,
   <a href="#nor">nor</a>,
   <a href="#or">or</a>,
   <a href="#prog1">prog1</a>,
   <a href="#prog2">prog2</a>,
   <a href="#state">state</a>,
   <a href="#unless">unless</a>,
   <a href="#until">until</a>,
   <a href="#when">when</a>,
   <a href="#while">while</a>,
and the bodies of <code><a href="#*Run">*Run</a></code> tasks.

</dl>

<p><code>@</code> is generally local to functions and methods, its value is
automatically saved upon function entry and restored at exit.


<p><hr>
<h3><a name="cmp">Comparing</a></h3>

<p>In Pico Lisp, it is legal to compare data items of arbitrary type. Any two
items are either

<p><dl>

<dt>Identical
<dd>They are the same memory object (pointer equality). For example, two
internal symbols with the same name are identical.

<dt>Equal
<dd>They are equal in every respect (structure equality), but need not to be
identical. Examples are numbers with the same value, transient symbols with the
same name or lists with equal elements.

<dt>Or they have a well-defined ordinal relationship
<dd>Numbers are comparable by their numeric value, strings by their name, and
lists recursively by their elements (if the <code>CAR</code>'s are equal, their
<code>CDR</code>'s are compared). For differing types, the following rule
applies: Numbers are less than symbols, and symbols are less than lists. As
special cases, <code>NIL</code> is always less than anything else, and
<code>T</code> is always greater than anything else.

</dl>

<p>To demonstrate this, <code><a href="#sort">sort</a></code> a list of mixed
data types:

<p><pre><code>
: (sort '("abc" T (d e f) NIL 123 DEF))
-> (NIL 123 DEF "abc" (d e f) T)
</code></pre>

<p>See also <code><a href="#max">max</a></code>, <code><a
href="#min">min</a></code>, <code><a href="#rank">rank</a></code>, <code><a
href="#<"><</a></code>, <code><a href="#=">=</a></code>, <code><a
href="#>">></a></code> etc.


<p><hr>
<h3><a name="oop">OO Concepts</a></h3>

<p>Pico Lisp comes with built-in object oriented extensions. There seems to be a
common agreement upon three criteria for object orientation:

<p><dl>
<dt>Encapsulation
<dd>Code and data are encapsulated into <u>objects</u>, giving them both a
<u>behavior</u> and a <u>state</u>. Objects communicate by sending and receiving
<u>messages</u>.

<dt>Inheritance
<dd>Objects are organized into <u>classes</u>. The behavior of an object is
inherited from its class(es) and superclass(es).

<dt>Polymorphism
<dd>Objects of different classes may behave differently in response to the same
message. For that, classes may define different methods for each message.

</dl>

<p>Pico Lisp implements both objects and classes with symbols. Object-local data
are stored in the symbol's property list, while the code (methods) and links to
the superclasses are stored in the symbol's <code>VAL</code> (encapsulation).

<p>In fact, there is no formal difference between objects and classes (except
that objects usually are anonymous symbols containing mostly local data, while
classes are named internal symbols with an emphasis on method definitions). At
any time, a class may be assigned its own local data (class variables), and any
object can receive individual method definitions in addition to (or overriding)
those inherited from its (super)classes.

<p>Pico Lisp supports multiple inheritance. The <code>VAL</code> of each object
is a (possibly empty) association list of message symbols and method bodies,
concatenated with a list of classes. When a message is sent to an object, it is
searched in the object's own method list, and then (with a left-to-right
depth-first search) in the tree of its classes and superclasses. The first
method found is executed and the search stops. The search may be explicitly
continued with the <code><a href="#extra">extra</a></code> and <code><a
href="#super">super</a></code> functions.

<p>Thus, which method is actually executed when a message is sent to an object
depends on the classes that the object is currently linked to (polymorphism). As
the method search is fully dynamic (late binding), an object's type (i.e. its
classes and method definitions) can be changed even at runtime!

<p>While a method body is being executed, the global variable <code><a
href="#This">This</a></code> is set to the current object, allowing the use of
the short-cut property functions <code><a href="#=:">=:</a></code>, <code><a
href="#:">:</a></code> and <code><a href="#::">::</a></code>.


<p><hr>
<h3><a name="dbase">Database</a></h3>

<p>On the lowest level, a Pico Lisp database is simply a collection of <a
href="#external">external symbols</a>. They reside in a database file, and are
dynamically swapped in and out of memory. Only one database file (pool) can be
open at any time (<code><a href="#pool">pool</a></code>).

<p>The symbols in the database can be used to store arbitrary information
structures. In typical use, some symbols represent nodes of search trees, by
holding keys, values, and links to subtrees in their <code>VAL</code>'s. Such a
search tree in the database is called <u>index</u>.

<p>For the most part, other symbols in the database are objects derived from the
<code>+Entity</code> class.

<p>Entities depend on objects of the <code>+Relation</code> class hierarchy.
Relation-objects manage the property values of entities, they define the
application database model and are responsible for the integrity of mutual
object references and index trees.

<p>Relations are stored as properties in the entity classes, their methods are
invoked as daemons whenever property values in an entity are changed. When
defining an <code>+Entity</code> class, relations are defined - in addition to
the method definitions of a normal class - with the <code><a
href="#rel">rel</a></code> function. Predefined relation classes include

<p><ul>
<li>Primitive types like
   <dl>
   <dt><code>+Symbol</code>
   <dd>Symbolic data
   <dt><code>+String</code>
   <dd>Strings (just a general case of symbols)
   <dt><code>+Number</code>
   <dd>Integers and fixed-point numbers
   <dt><code>+Date</code>
   <dd>Calendar date values, represented by a number
   <dt><code>+Time</code>
   <dd>Time-of-the-day values, represented by a number
   <dt><code>+Blob</code>
   <dd>"Binary large objects" stored in separate files
   </dl>
<li>Object-to-object relations
   <dl>
   <dt><code>+Link</code>
   <dd>A reference to some other entity
   <dt><code>+Hook</code>
   <dd>A reference to an entity holding object-local index trees
   <dt><code>+Joint</code>
   <dd>A bi-directional reference to some other entity
   </dl>
<li>Container prefix classes like
   <dl>
   <dt><code>+List</code>
   <dd>A list of any of the other primitive or object relation types
   <dt><code>+Bag</code>
   <dd>A list containing a mixture of any of the other types
   </dl>
<li>Index prefix classes
   <dl>
   <dt><code>+Ref</code>
   <dd>An index with other primitives or entities as key
   <dt><code>+Key</code>
   <dd>A unique index with other primitives or entities as key
   <dt><code>+Idx</code>
   <dd>A full-text index, typically for strings
   <dt><code>+Sn</code>
   <dd>Tolerant index, using the Soundex-Algorithm
   </dl>
<li>Booleans
   <dl>
   <dt><code>+Bool</code>
   <dd><code>T</code> or <code>NIL</code>
   </dl>
<li>And a catch-all class
   <dl>
   <dt><code>+Any</code>
   <dd>Not specified, may be any of the above relations
   </dl>
</ul>


<p><hr>
<h3><a name="pilog">Pilog (Pico Lisp Prolog)</a></h3>

<p>A declarative language is built on top of Pico Lisp, that has the semantics
of Prolog, but uses the syntax of Lisp.

<p>For an explanation of Prolog's declarative programming style, an introduction
like "Programming in Prolog" by Clocksin/Mellish (Springer-Verlag 1981) is
recommended.

<p>Facts and rules can be declared with the <code><a href="#be">be</a></code>
function. For example, a Prolog fact '<code>likes(john,mary).</code>' is written
in Pilog as:

<p><pre><code>
(be likes (John Mary))
</code></pre>

<p>and a rule '<code>likes(john,X) :- likes(X,wine), likes(X,food).</code>' is
in Pilog:

<p><pre><code>
(be likes (John @X) (likes @X wine) (likes @X food))
</code></pre>

<p>As in Prolog, the difference between facts and rules is that the latter ones
have conditions and usually contain variables. A variable in Pilog is any symbol
starting with an at-mark ("<code>@</code>").

<p>The <i>cut</i> operator of Prolog (usually written as an exclamation mark
(<code>!</code>)) is the symbol <code>T</code> in Pilog.

<p>Pilog can be called from Lisp and vice versa:

<ul>

<li>The interface from Lisp is via the functions <code><a
href="#goal">goal</a></code> (prepare a query from Lisp data) and <code><a
href="#prove">prove</a></code> (return an association list of successful
bindings).

<li>When the <code>CAR</code> of a Pilog clause is a Pilog variable, the
<code>CDR</code> is executed as a Lisp expression and the result unified with
that variable.

<li>Within such a Lisp expression in a Pilog clause, the current bindings of
Pilog variables can be accessed with the <code><a href="#lookup">-&gt</a></code>
function.

</ul>

<p>An interactive query can be done with the <code><a href="#quest">?</a></code>
function:

<p><pre><code>
(? (likes John @X))
</code></pre>

<p>This will print all solutions, waiting for user input after each line. If a
non-empty line (not just a <code>RETURN</code> key, but for example a dot
(<code>.</code>) followed by <code>RETURN</code>) is entered, it will terminate.


<p><hr>
<h3><a name="conv">Naming Conventions</a></h3>

<p>It was necessary to introduce - and adhere to - a set of conventions for Pico
Lisp symbol names. Because all (internal) symbols have a global scope (there are
no packages or name spaces), and each symbol can only have either a value or
function definition, it would otherwise be very easy to introduce name
conflicts. Besides this, source code readability is increased when the scope
of a symbol is indicated by its name.

<p>These conventions are not hard-coded into the language, but should be so into
the head of the programmer. Here are the most commonly used ones:

<p><ul>
<li>Global variables start with an asterisk "<code>*</code>"
<li>Functions and other global symbols start with a lower case letter
<li>Locally bound symbols start with an upper case letter
<li>Local functions start with an underscore "<code>_</code>"
<li>Classes start with a plus-sign "<code>+</code>"
<li>Methods end with a right arrow "<code>></code>"
</ul>

<p>For historical reasons, the global constant symbols <code>T</code> and
<code>NIL</code> do not obey these rules, and are written in upper case.

<p>For example, a local variable could easily overshadow a function definition:

<p><pre><code>
: (de max-speed (car)
   (.. (get car 'speeds) ..) )
-> max-speed
</code></pre>

<p>Inside the body of <code>max-speed</code> (and all other functions called
during that execution) the kernel function <code>car</code> is redefined to some
other value, and will surely crash if something like <code>(car Lst)</code> is
executed. Instead, it is safe to write:

<p><pre><code>
: (de max-speed (Car)            # 'Car' with upper case first letter
   (.. (get Car 'speeds) ..) )
-> max-speed
</code></pre>

<p>Note that there are also some strict naming rules (as opposed to the
voluntary conventions) that are required by the corresponding kernel
functionalities, like:

<p><ul>
<li>Transient symbols are enclosed in double quotes (see <a href="#transient-io">Transient Symbols</a>)
<li>External symbols are enclosed in braces (see <a href="#external-io">External Symbols</a>)
<li>Pattern-Wildcards start with an at-mark "<code>@</code>" (see <a href="#match">match</a> and <a href="#fill">fill</a>)
<li>Symbols referring to a shared library contain a colon "<code>lib:sym</code>"
</ul>

<p>With that, the last of the above conventions (local functions start with an
underscore) is not really necessary, because true local scope can be enforced
with transient symbols.


<p><hr>
<h3><a name="trad">Breaking Traditions</a></h3>

<p>Pico Lisp does not try very hard to be compatible with traditional Lisp
systems. If you are used to some other Lisp dialects, you may notice the
following differences:

<p><dl>

<dt>Case Sensitivity
<dd>Pico Lisp distinguishes between upper case and lower case characters in
symbol names. Thus, <code>CAR</code> and <code>car</code> are different symbols,
which was not the case in traditional Lisp systems.

<dt><code>QUOTE</code>
<dd>In traditional Lisp, the <code>QUOTE</code> function returns its
<i>first</i> unevaluated argument. In Pico Lisp, on the other hand,
<code>quote</code> returns <i>all</i> (unevaluated) argument(s).

<dt><code>LAMBDA</code>
<dd>The <code>LAMBDA</code> function, in some way at the heart of traditional
Lisp, is completely missing (and <code>quote</code> is used instead).

<dt><code>PROG</code>
<dd>The <code>PROG</code> function of traditional Lisp, with its GOTO and RETURN
functionality, is also missing. Pico Lisp's <code>prog</code> function is just a
simple sequencer (as <code>PROGN</code> ins some Lisps).

<dt>Function/Value
<dd>In Pico Lisp, a symbol cannot have a value <i>and</i> a function definition
at the same time. Though this is a disadvantage at first sight, it allows a
completely uniform handling of functional data.

</dl>


<p><hr>
<h2><a name="foo">Function Reference</a></h2>

<p>This section provides a reference manual for the kernel functions, and some
extensions. The first part is a thematically grouped list of indexes into the
second part, which contains the function specifications in alphabetical order.

<p>Though Pico Lisp is a dynamically typed language (resolved at runtime, as
opposed to statically (compile-time) typed languages), many functions can only
accept and/or return a certain set of data types. For each function, the
expected argument types and return values are described with the following
abbreviations:

<p>The primary data types:

<p><ul>
<li><code>num</code> - Number
<li><code>sym</code> - Symbol
<li><code>lst</code> - List
</ul>

<p>Other (derived) data types

<p><ul>
<li><code>any</code> - Anything: Any primary data type
<li><code>flg</code> - Flag: Boolean value (<code>NIL</code> or non-<code>NIL</code>)
<li><code>cnt</code> - A count or a small number
<li><code>dat</code> - Date: Days since first of March, in the year 0 A.D.
<li><code>tim</code> - Time: Seconds since midnight
<li><code>obj</code> - Object/Class: A symbol with methods and/or classes
<li><code>var</code> - Variable: Either a symbol or a cell
<li><code>exe</code> - Executable: A list as executable expression (<code>eval</code>)
<li><code>prg</code> - Prog-Body: A list of executable expressions (<code>run</code>)
<li><code>fun</code> - Function: Either a number (code-pointer), a symbol (message) or a list (lambda)
<li><code>msg</code> - Message: A symbol sent to an object (to invoke a method)
<li><code>cls</code> - Class: A symbol defined as an object's class
<li><code>typ</code> - Type: A list of <code>cls</code> symbols
<li><code>pid</code> - Process ID: A number, the ID of a Unix process
</ul>

<p>
<a href="#a-foo">A</a>
<a href="#b-foo">B</a>
<a href="#c-foo">C</a>
<a href="#d-foo">D</a>
<a href="#e-foo">E</a>
<a href="#f-foo">F</a>
<a href="#g-foo">G</a>
<a href="#h-foo">H</a>
<a href="#i-foo">I</a>
<a href="#j-foo">J</a>
<a href="#k-foo">K</a>
<a href="#l-foo">L</a>
<a href="#m-foo">M</a>
<a href="#n-foo">N</a>
<a href="#o-foo">O</a>
<a href="#p-foo">P</a>
<a href="#q-foo">Q</a>
<a href="#r-foo">R</a>
<a href="#s-foo">S</a>
<a href="#t-foo">T</a>
<a href="#u-foo">U</a>
<a href="#v-foo">V</a>
<a href="#w-foo">W</a>
<a href="#x-foo">X</a>
<a href="#y-foo">Y</a>
<a href="#z-foo">Z</a>
<a href="#pun-foo">Other</a>

<p><dl>

<dt>Symbol Functions
<dd><code>
   <a href="#new">new</a>
   <a href="#sym">sym</a>
   <a href="#str">str</a>
   <a href="#char">char</a>
   <a href="#name">name</a>
   <a href="#spQ">sp?</a>
   <a href="#patQ">pat?</a>
   <a href="#funQ">fun?</a>
   <a href="#intern">intern</a>
   <a href="#extern">extern</a>
   <a href="#====">====</a>
   <a href="#boxQ">box?</a>
   <a href="#strQ">str?</a>
   <a href="#extQ">ext?</a>
   <a href="#touch">touch</a>
   <a href="#zap">zap</a>
   <a href="#length">length</a>
   <a href="#size">size</a>
   <a href="#format">format</a>
   <a href="#chop">chop</a>
   <a href="#pack">pack</a>
   <a href="#glue">glue</a>
   <a href="#text">text</a>
   <a href="#preQ">pre?</a>
   <a href="#subQ">sub?</a>
   <a href="#lowQ">low?</a>
   <a href="#uppQ">upp?</a>
   <a href="#lowc">lowc</a>
   <a href="#uppc">uppc</a>
   <a href="#fold">fold</a>
   <a href="#val">val</a>
   <a href="#set">set</a>
   <a href="#setq">setq</a>
   <a href="#def">def</a>
   <a href="#de">de</a>
   <a href="#dm">dm</a>
   <a href="#xchg">xchg</a>
   <a href="#on">on</a>
   <a href="#off">off</a>
   <a href="#onOff">onOff</a>
   <a href="#zero">zero</a>
   <a href="#one">one</a>
   <a href="#default">default</a>
   <a href="#let">let</a>
   <a href="#letQ">let?</a>
   <a href="#use">use</a>
   <a href="#push">push</a>
   <a href="#push1">push1</a>
   <a href="#pop">pop</a>
   <a href="#cut">cut</a>
   <a href="#del">del</a>
   <a href="#queue">queue</a>
   <a href="#fifo">fifo</a>
   <a href="#idx">idx</a>
   <a href="#lup">lup</a>
</code>

<dt>Property Access
<dd><code>
   <a href="#put">put</a>
   <a href="#get">get</a>
   <a href="#prop">prop</a>
   <a href="#=:">=:</a>
   <a href="#:">:</a>
   <a href="#::">::</a>
   <a href="#putl">putl</a>
   <a href="#getl">getl</a>
   <a href="#wipe">wipe</a>
   <a href="#meta">meta</a>
</code>

<dt>Predicates
<dd><code>
   <a href="#atom">atom</a>
   <a href="#pair">pair</a>
   <a href="#listQ">lst?</a>
   <a href="#numQ">num?</a>
   <a href="#symQ">sym?</a>
   <a href="#flgQ">flg?</a>
   <a href="#spQ">sp?</a>
   <a href="#patQ">pat?</a>
   <a href="#funQ">fun?</a>
   <a href="#boxQ">box?</a>
   <a href="#strQ">str?</a>
   <a href="#extQ">ext?</a>
   <a href="#bool">bool</a>
   <a href="#not">not</a>
   <a href="#==">==</a>
   <a href="#n==">n==</a>
   <a href="#=">=</a>
   <a href="#<>"><&gt</a>
   <a href="#=0">=0</a>
   <a href="#=T">=T</a>
   <a href="#n0">n0</a>
   <a href="#nT">nT</a>
   <a href="#<"><</a>
   <a href="#<="><=</a>
   <a href="#>">&gt</a>
   <a href="#>=">&gt=</a>
   <a href="#match">match</a>
</code>

<dt>Arithmetics
<dd><code>
   <a href="#+">+</a>
   <a href="#-">-</a>
   <a href="#*">*</a>
   <a href="#/">/</a>
   <a href="#%">%</a>
   <a href="#*/">*/</a>
   <a href="#inc">inc</a>
   <a href="#dec">dec</a>
   <a href="#>>">>></a>
   <a href="#lt0">lt0</a>
   <a href="#ge0">ge0</a>
   <a href="#gt0">gt0</a>
   <a href="#abs">abs</a>
   <a href="#bitQ">bit?</a>
   <a href="#&">&</a>
   <a href="#|">|</a>
   <a href="#x|">x|</a>
   <a href="#sqrt">sqrt</a>
   <a href="#seed">seed</a>
   <a href="#rand">rand</a>
   <a href="#max">max</a>
   <a href="#min">min</a>
   <a href="#length">length</a>
   <a href="#size">size</a>
   <a href="#format">format</a>
</code>

<dt>List Processing
<dd><code>
   <a href="#car">car</a>
   <a href="#cdr">cdr</a>
   <a href="#caar">caar</a>
   <a href="#cadr">cadr</a>
   <a href="#cdar">cdar</a>
   <a href="#cddr">cddr</a>
   <a href="#caaar">caaar</a>
   <a href="#caadr">caadr</a>
   <a href="#cadar">cadar</a>
   <a href="#caddr">caddr</a>
   <a href="#cdaar">cdaar</a>
   <a href="#cdadr">cdadr</a>
   <a href="#cddar">cddar</a>
   <a href="#cdddr">cdddr</a>
   <a href="#cadddr">cadddr</a>
   <a href="#cddddr">cddddr</a>
   <a href="#nth">nth</a>
   <a href="#con">con</a>
   <a href="#cons">cons</a>
   <a href="#conc">conc</a>
   <a href="#circ">circ</a>
   <a href="#rot">rot</a>
   <a href="#list">list</a>
   <a href="#need">need</a>
   <a href="#make">make</a>
   <a href="#made">made</a>
   <a href="#chain">chain</a>
   <a href="#link">link</a>
   <a href="#copy">copy</a>
   <a href="#mix">mix</a>
   <a href="#append">append</a>
   <a href="#delete">delete</a>
   <a href="#delq">delq</a>
   <a href="#replace">replace</a>
   <a href="#strip">strip</a>
   <a href="#split">split</a>
   <a href="#reverse">reverse</a>
   <a href="#flip">flip</a>
   <a href="#trim">trim</a>
   <a href="#clip">clip</a>
   <a href="#head">head</a>
   <a href="#tail">tail</a>
   <a href="#stem">stem</a>
   <a href="#fin">fin</a>
   <a href="#last">last</a>
   <a href="#member">member</a>
   <a href="#memq">memq</a>
   <a href="#mmeq">mmeq</a>
   <a href="#sect">sect</a>
   <a href="#diff">diff</a>
   <a href="#index">index</a>
   <a href="#offset">offset</a>
   <a href="#assoc">assoc</a>
   <a href="#asoq">asoq</a>
   <a href="#rank">rank</a>
   <a href="#sort">sort</a>
   <a href="#length">length</a>
   <a href="#size">size</a>
   <a href="#val">val</a>
   <a href="#set">set</a>
   <a href="#xchg">xchg</a>
   <a href="#push">push</a>
   <a href="#push1">push1</a>
   <a href="#pop">pop</a>
   <a href="#cut">cut</a>
   <a href="#queue">queue</a>
   <a href="#fifo">fifo</a>
   <a href="#idx">idx</a>
   <a href="#get">get</a>
   <a href="#fill">fill</a>
   <a href="#apply">apply</a>
</code>

<dt>Control Flow
<dd><code>
   <a href="#load">load</a>
   <a href="#args">args</a>
   <a href="#next">next</a>
   <a href="#arg">arg</a>
   <a href="#rest">rest</a>
   <a href="#pass">pass</a>
   <a href="#quote">quote</a>
   <a href="#as">as</a>
   <a href="#lit">lit</a>
   <a href="#eval">eval</a>
   <a href="#run">run</a>
   <a href="#def">def</a>
   <a href="#de">de</a>
   <a href="#dm">dm</a>
   <a href="#box">box</a>
   <a href="#new">new</a>
   <a href="#type">type</a>
   <a href="#isa">isa</a>
   <a href="#method">method</a>
   <a href="#meth">meth</a>
   <a href="#send">send</a>
   <a href="#try">try</a>
   <a href="#super">super</a>
   <a href="#extra">extra</a>
   <a href="#with">with</a>
   <a href="#bind">bind</a>
   <a href="#job">job</a>
   <a href="#let">let</a>
   <a href="#letQ">let?</a>
   <a href="#use">use</a>
   <a href="#and">and</a>
   <a href="#or">or</a>
   <a href="#nand">nand</a>
   <a href="#nor">nor</a>
   <a href="#xor">xor</a>
   <a href="#bool">bool</a>
   <a href="#not">not</a>
   <a href="#nil">nil</a>
   <a href="#t">t</a>
   <a href="#prog">prog</a>
   <a href="#prog1">prog1</a>
   <a href="#prog2">prog2</a>
   <a href="#if">if</a>
   <a href="#if2">if2</a>
   <a href="#ifn">ifn</a>
   <a href="#when">when</a>
   <a href="#unless">unless</a>
   <a href="#cond">cond</a>
   <a href="#nond">nond</a>,
   <a href="#case">case</a>
   <a href="#state">state</a>
   <a href="#while">while</a>
   <a href="#until">until</a>
   <a href="#loop">loop</a>
   <a href="#do">do</a>
   <a href="#at">at</a>
   <a href="#for">for</a>
   <a href="#catch">catch</a>
   <a href="#throw">throw</a>
   <a href="#finally">finally</a>
   <a href="#!">!</a>
   <a href="#e">e</a>
   <a href="#$">$</a>
   <a href="#sys">sys</a>
   <a href="#call">call</a>
   <a href="#tick">tick</a>
   <a href="#kill">kill</a>
   <a href="#quit">quit</a>
   <a href="#fork">fork</a>
   <a href="#bye">bye</a>
</code>

<dt>Mapping
<dd><code>
   <a href="#apply">apply</a>
   <a href="#pass">pass</a>
   <a href="#all">all</a>
   <a href="#maps">maps</a>
   <a href="#map">map</a>
   <a href="#mapc">mapc</a>
   <a href="#maplist">maplist</a>
   <a href="#mapcar">mapcar</a>
   <a href="#mapcon">mapcon</a>
   <a href="#mapcan">mapcan</a>
   <a href="#filter">filter</a>
   <a href="#seek">seek</a>
   <a href="#find">find</a>
   <a href="#pick">pick</a>
   <a href="#cnt">cnt</a>
   <a href="#sum">sum</a>
   <a href="#maxi">maxi</a>
   <a href="#mini">mini</a>
   <a href="#fish">fish</a>
   <a href="#by">by</a>
</code>

<dt>Input/Output
<dd><code>
   <a href="#path">path</a>
   <a href="#in">in</a>
   <a href="#out">out</a>
   <a href="#pipe">pipe</a>
   <a href="#ctl">ctl</a>
   <a href="#any">any</a>
   <a href="#sym">sym</a>
   <a href="#str">str</a>
   <a href="#load">load</a>
   <a href="#hear">hear</a>
   <a href="#tell">tell</a>
   <a href="#key">key</a>
   <a href="#poll">poll</a>
   <a href="#peek">peek</a>
   <a href="#char">char</a>
   <a href="#skip">skip</a>
   <a href="#eof">eof</a>
   <a href="#from">from</a>
   <a href="#till">till</a>
   <a href="#line">line</a>
   <a href="#format">format</a>
   <a href="#read">read</a>
   <a href="#print">print</a>
   <a href="#println">println</a>
   <a href="#printsp">printsp</a>
   <a href="#prin">prin</a>
   <a href="#prinl">prinl</a>
   <a href="#space">space</a>
   <a href="#flush">flush</a>
   <a href="#rewind">rewind</a>
   <a href="#rd">rd</a>
   <a href="#pr">pr</a>
   <a href="#wr">wr</a>
   <a href="#rpc">rpc</a>
   <a href="#wait">wait</a>
   <a href="#sync">sync</a>
   <a href="#echo">echo</a>
   <a href="#info">info</a>
   <a href="#dir">dir</a>
   <a href="#lines">lines</a>
   <a href="#open">open</a>
   <a href="#close">close</a>
   <a href="#port">port</a>
   <a href="#listen">listen</a>
   <a href="#accept">accept</a>
   <a href="#host">host</a>
   <a href="#connect">connect</a>
   <a href="#nagle">nagle</a>
   <a href="#udp">udp</a>
</code>

<dt>Database
<dd><code>
   <a href="#pool">pool</a>
   <a href="#journal">journal</a>
   <a href="#id">id</a>
   <a href="#seq">seq</a>
   <a href="#lieu">lieu</a>
   <a href="#lock">lock</a>
   <a href="#begin">begin</a>
   <a href="#commit">commit</a>
   <a href="#rollback">rollback</a>
   <a href="#mark">mark</a>
   <a href="#free">free</a>
   <a href="#dbck">dbck</a>
   <a href="#rel">rel</a>
</code>

<dt>Pilog
<dd><code>
   <a href="#be">be</a>
   <a href="#goal">goal</a>
   <a href="#prove">prove</a>
   <a href="#lookup">-&gt</a>
   <a href="#unify">unify</a>
   <a href="#quest">?</a>
</code>

<dt>Debugging
<dd><code>
   <a href="#stat">stat</a>
   <a href="#debug">debug</a>
   <a href="#trace">trace</a>
</code>

<dt>System Functions
<dd><code>
   <a href="#argv">argv</a>
   <a href="#opt">opt</a>
   <a href="#gc">gc</a>
   <a href="#raw">raw</a>
   <a href="#die">die</a>
   <a href="#protect">protect</a>
   <a href="#heap">heap</a>
   <a href="#env">env</a>
   <a href="#up">up</a>
   <a href="#stk">stk</a>
   <a href="#stat">stat</a>
   <a href="#date">date</a>
   <a href="#time">time</a>
   <a href="#usec">usec</a>
   <a href="#stamp">stamp</a>
   <a href="#pwd">pwd</a>
   <a href="#cd">cd</a>
   <a href="#ctty">ctty</a>
   <a href="#info">info</a>
   <a href="#dir">dir</a>
   <a href="#call">call</a>
   <a href="#tick">tick</a>
   <a href="#kill">kill</a>
   <a href="#quit">quit</a>
   <a href="#fork">fork</a>
   <a href="#bye">bye</a>
</code>

<dt>Globals
<dd><code>
   <a href="#nilSym">NIL</a>
   <a href="#*DB">*DB</a>
   <a href="#*Solo">*Solo</a>
   <a href="#^">^</a>
   <a href="#@">@</a>
   <a href="#@@">@@</a>
   <a href="#@@@">@@@</a>
   <a href="#This">This</a>
   <a href="#T">T</a>
   <a href="#*Dbg">*Dbg</a>
   <a href="#*PPid">*PPid</a>
   <a href="#*Pid">*Pid</a>
   <a href="#*Scl">*Scl</a>
   <a href="#*Class">*Class</a>
   <a href="#*Run">*Run</a>
   <a href="#*Led">*Led</a>
   <a href="#*Err">*Err</a>
   <a href="#*Rst">*Rst</a>
   <a href="#*Msg">*Msg</a>
   <a href="#*Uni">*Uni</a>
   <a href="#*Adr">*Adr</a>
   <a href="#*Fork">*Fork</a>
   <a href="#*Bye">*Bye</a>
</code>

</dl>


<p><hr>
<h3><a name="a-foo">A</a></h3>

<p><dl>

<dt><a name="abs"><code>(abs 'num) -> num</code></a>
<dd>Returns the absolute value of the <code>num</code> argument.

<p><pre><code>
: (abs -7)
-> 7
: (abs 7)
-> 7
</code></pre>

<p><dt><a name="accept"><code>(accept 'cnt) -> cnt | NIL</code></a>
<dd>Accepts a connection on descriptor <code>cnt</code> (as received by
<code><a href="#port">port</a></code>), and returns the new socket descriptor
<code>cnt</code>. The global variable <code>*Adr</code> is set to the IP address
of the client. See also <code><a href="#listen">listen</a></code>, <code><a
href="#connect">connect</a></code> and <code><a href="#*Adr">*Adr</a></code>.

<p><pre><code>
: (setq *Socket
   (accept (port 6789)) )        # Accept connection at port 6789
-> 4
</code></pre>

<p><dt><a name="all"><code>(all 'fun) -> any</code></a>
<dd>Applies <code>fun</code> to all internal symbols in the system. Returns the
result of the last application.

<p><pre><code>
: (all printsp)  # Print the names of all internal symbols
delWord +PwField +Fmt tail char cons month ..
.. conc cond -> cond

# Find all symbols starting with an underscore character
: (make (all '((X) (and (= "_" (car (chop X))) (link X)))))
-> (_ed _isa _delL _delR _dbg _del _query _scan _hex _boxSend _put)
</code></pre>

<p><dt><a name="and"><code>(and 'any ..) -> any</code></a>
<dd>Logical AND. The expressions <code>any</code> are evaluated from left to
right. If <code>NIL</code> is encountered, <code>NIL</code> is returned
immediately. Else the result of the last expression is returned.

<p><pre><code>
: (and (= 3 3) (read))
abc  # User input
-> abc
: (and (= 3 4) (read))
-> NIL
</code></pre>

<p><dt><a name="any"><code>(any 'sym) -> any</code></a>
<dd>Parses <code>any</code> from the name of <code>sym</code>. See also <code><a
href="#sym">sym</a></code> and <code><a href="#str">str</a></code>.

<p><pre><code>
: (any "(a b # Comment^Jc d)")
-> (a b c d)
: (any "\"A String\"")
-> "A String"
</code></pre>

<p><dt><a name="append"><code>(append 'lst ..) -> lst</code></a>
<dd>Appends all argument lists. See also <code><a href="#conc">conc</a></code>.

<p><pre><code>
: (append '(a b c) (1 2 3))
-> (a b c 1 2 3)
: (append (1) (2) (3) 4)
-> (1 2 3 . 4)
</code></pre>

<p><dt><a name="apply"><code>(apply 'fun 'lst ['any ..]) -> any</code></a>
<dd>Applies <code>fun</code> to <code>lst</code>. If additional <code>any</code>
arguments are given, they are applied as leading elements of <code>lst</code>.

<p><pre><code>
: (apply + (1 2 3))
-> 6
: (apply * (5 6) 3 4)
-> 360
: (apply '((X Y Z) (* X (+ Y Z))) (3 4 5))
-> 27
</code></pre>

<p><dt><a name="arg"><code>(arg ['cnt]) -> any</code></a>
<dd>Can only be used inside functions with a variable number of arguments (with
<code>@</code>). If <code>cnt</code> is not given, the value that was returned
from the last call to <code>next</code>) is returned. Otherwise, the
<code>cnt</code>'th remaining argument is returned. See also <code><a
href="#args">args</a></code>, <code><a href="#next">next</a></code>, <code><a
href="#rest">rest</a></code> and <code><a href="#pass">pass</a></code>.

<p><pre><code>
: (de foo @ (println (next) (arg)))    # Print argument twice
-> foo
: (foo 123)
123 123
-> 123
: (de foo @
   (println (arg 1) (arg 2))
   (println (next))
   (println (arg 1) (arg 2)) )
-> foo
: (foo 'a 'b 'c)
a b
a
b c
-> c
</code></pre>

<p><dt><a name="args"><code>(args) -> flg</code></a>
<dd>Can only be used inside functions with a variable number of arguments (with
<code>@</code>). Returns <code>T</code> when there are more arguments to be
fetched from the internal list. See also <code><a href="#next">next</a></code>,
<code><a href="#arg">arg</a></code>, <code><a href="#rest">rest</a></code> and
<code><a href="#pass">pass</a></code>.

<p><pre><code>
: (de foo @ (println (args)))       # Test for arguments
-> foo
: (foo)                             # No arguments
NIL
-> NIL
: (foo NIL)                         # One argument
T
-> T
: (foo 123)                         # One argument
T
-> T
</code></pre>

<p><dt><a name="argv"><code>(argv [sym ..] [. sym]) -> lst|sym</code></a>
<dd>If called without arguments, <code>argv</code> returns a list of strings
containing all remaining command line arguments. Otherwise, the <code>sym</code>
arguments are subsequently bound to the command line arguments. A hyphen
"<code>-</code>" can be used to stop <code>load</code>ing further arguments. See
also <code><a href="#invoc">Invocation</a></code> and <code><a
href="#opt">opt</a></code>.

<p><pre><code>
$ ./p -"println 'Ok" - abc 123
Ok
: (argv)
-> ("abc" "123")
: (argv A B)
-> "123"
: A
-> "abc"
: B
-> "123"
: (argv . Lst)
-> ("abc" "123")
: Lst
-> ("abc" "123")
</code></pre>

<p><dt><a name="as"><code>(as 'any1 . any2) -> any2 | NIL</code></a>
<dd>Returns <code>any2</code> unevaluated when <code>any1</code> evaluates to
non-<code>NIL</code>. Otherwise <code>NIL</code> is returned. <code>(as Flg A B
C)</code> is equivalent to <code>(and Flg '(A B C))</code>. See also <code><a
href="#quote">quote</a></code>.

<p><pre><code>
: (as (= 3 3) A B C)
-> (A B C)
</code></pre>

<p><dt><a name="asoq"><code>(asoq 'any 'lst) -> lst</code></a>
<dd>Searches an association list. Returns the first element from
<code>lst</code> with <code>any</code> as its <code>CAR</code>, or
<code>NIL</code> if no match is found. <code><a href="#==">==</a></code> is used
for comparison (pointer equality). See also <code><a
href="#assoc">assoc</a></code>, <code><a href="#delq">delq</a></code>, <code><a
href="#memq">memq</a></code> and <code><a href="#mmeq">mmeq</a></code>.

<p><pre><code>
: (asoq 999 '((999 1 2 3) (b . 7) ("ok" "Hello")))
-> NIL
: (asoq 'b '((999 1 2 3) (b . 7) ("ok" "Hello")))
-> (b . 7)
</code></pre>

<p><dt><a name="assoc"><code>(assoc 'any 'lst) -> lst</code></a>
<dd>Searches an association list. Returns the first element from
<code>lst</code> with its <code>CAR</code> equal to <code>any</code>, or
<code>NIL</code> if no match is found.

<p><pre><code>
: (assoc "b" '((999 1 2 3) ("b" . 7) ("ok" "Hello")))
-> ("b" . 7)
: (assoc 999 '((999 1 2 3) ("b" . 7) ("ok" "Hello")))
-> (999 1 2 3)
: (assoc 'u '((999 1 2 3) ("b" . 7) ("ok" "Hello")))
-> NIL
</code></pre>

<p><dt><a name="at"><code>(at '(cnt1 . cnt2) . prg) -> any</code></a>
<dd>Increments <code>cnt1</code> (destructively), and returns <code>NIL</code>
when it is less than <code>cnt2</code>. Otherwise, <code>prg</code> is executed
and <code>cnt1</code> is reset to zero. Returns the result of <code>prg</code>.

<p><pre><code>
: (do 11 (prin ".") (at (0 . 3) (prin "!")))
...!...!...!..-> NIL
</code></pre>

<p><dt><a name="atom"><code>(atom 'any) -> flg</code></a>
<dd>Returns <code>T</code> when the argument <code>any</code> is an atom (a
number or a symbol). See also <code><a href="#pair">pair</a></code>.

<p><pre><code>
: (atom 123)
-> T
: (atom 'a)
-> T
: (atom NIL)
-> T
: (atom (123))
-> NIL
</code></pre>


<p><hr>
<h3><a name="b-foo">B</a></h3>

<p><dt><a name="be"><code>(be sym . any) -> sym</code></a>
<dd>Declares a <a href="#pilog">Pilog</a> fact or rule for the <code>sym</code>
argument, by concatenating the <code>any</code> argument to the <code>T</code>
property of <code>sym</code>. See also <code><a href="#goal">goal</a></code> and
<code><a href="#prove">prove</a></code>.

<p><pre><code>
: (be likes (John Mary))
-> likes
: (be likes (John @X) (likes @X wine) (likes @X food))
-> likes
: (get 'likes T)
-> (((John Mary)) ((John @X) (likes @X wine) (likes @X food)))
: (? (likes John @X))
 @X=Mary
-> NIL
</code></pre>

<p><dt><a name="begin"><code>(begin) -> T</code></a>
<dd>Opens a nested transaction. Not needed for normal single-level transaction
processing with <code><a href="#commit">commit</a></code> and <code><a
href="#rollback">rollback</a></code>.

<p><pre><code>
: (pool "db")
-> T
: (put '{1} 'str "Hello")        # Set property in first level
-> "Hello"
: (begin)                        # Start second level
-> T
: (put '{1} 'str "abc")          # Set another value
-> "abc"
: (get '{1} 'str)
-> "abc"
: (rollback)                     # Rollback second level
-> NIL
: (get '{1} 'str)                # Value is restored
-> "Hello"
: (rollback)                     # Rollback top level
-> T
: (get '{1} 'str)                # Value is cleared
-> NIL
</code></pre>

<p><dt><a name="bind"><code>(bind 'sym|lst . prg) -> any</code></a>
<dd>Binds value(s) to symbol(s). The first argument <code>sym</code> must
evaluate to a symbol, a list of symbols, or to a list of symbol-value pairs. The
values of these symbols are saved (and the symbols bound to the values in the
last case), <code>prg</code> is executed, then the symbols are restored to their
original values. During execution of <code>prg</code>, the values of the symbols
can be temporarily modified. The return value is the result of <code>prg</code>.
See also <code><a href="#let">let</a></code>, <code><a
href="#job">job</a></code> and <code><a href="#use">use</a></code>.

<p><pre><code>
: (setq X 123)                               # X is 123
-> 123
: (bind 'X '((setq X "Hello") (println X)))  # Set X to "Hello", print it
"Hello"
-> "Hello"
: (bind '((X . 3) (Y . 4)) '((println X Y) (* X Y)))
3 4
-> 12
: X
-> 123                                       # X is restored to 123
</code></pre>

<p><dt><a name="bitQ"><code>(bit? 'num ..) -> num | NIL</code></a>
<dd>Returns the first <code>num</code> argument when all bits which are 1 in the
first argument are also 1 in all following arguments. See also <code><a
href="#&">&</a></code>, <code><a href="#|">|</a></code> and <code><a
href="#x|">x|</a></code>.

<p><pre><code>
: (bit? 7 15 255)
-> 7
: (bit? 1 3)
-> 1
: (bit? 1 2)
-> NIL
</code></pre>

<p><dt><a name="bool"><code>(bool 'any) -> flg</code></a>
<dd>Returns <code>T</code> when the argument <code>any</code> is
non-<code>NIL</code>. This function is only needed when <code>T</code> is
strictly required for a "true" condition (Usually, any non-<code>NIL</code>
value is considered to be "true"). See also <code><a
href="#flgQ">flg?</a></code>.

<p><pre><code>
: (and 3 4)
-> 4
: (bool (and 3 4))
-> T
</code></pre>

<p><dt><a name="box"><code>(box 'any) -> sym</code></a>
<dd>Creates and returns a new anonymous symbol. The initial value is set to the
<code>any</code> argument. See also <code><a href="#new">new</a></code> and
<code><a href="#boxQ">box?</a></code>.

<p><pre><code>
: (show (box '(A B C)))
$134425627 (A B C)
-> $134425627
</code></pre>

<p><dt><a name="boxQ"><code>(box? 'any) -> sym | NIL</code></a>
<dd>Returns the argument <code>any</code> when it is an anonymous symbol,
otherwise <code>NIL</code>. See also <code><a href="#box">box</a></code>,
<code><a href="#strQ">str?</a></code> and <code><a href="#extQ">ext?</a></code>.

<p><pre><code>
: (box? (new))
-> $134563468
: (box? 123)
-> NIL
: (box? 'a)
-> NIL
: (box? NIL)
-> NIL
</code></pre>

<p><dt><a name="by"><code>(by 'fun1 'fun2 'lst ..) -> lst</code></a>
<dd>Applies <code>fun1</code> to each element of <code>lst</code>. When
additional <code>lst</code> arguments are given, their elements are also passed
to <code>fun1</code>. Each result of <code>fun1</code> is CONSed with its
corresponding argument form the original <code>lst</code>, and collected into a
list which is passed to <code>fun2</code>. For the list returned from
<code>fun2</code>, the CAR elements returned by <code>fun1</code> are
(destructively) removed from each element.

<p><pre><code>
: (let (A 1 B 2 C 3) (by val sort '(C A B)))
-> (A B C)
: (by '((N) (bit? 1 N)) group (3 11 6 2 9 5 4 10 12 7 8 1))
-> ((3 11 9 5 7 1) (6 2 4 10 12 8))
</code></pre>

<p><dt><a name="bye"><code>(bye 'cnt|NIL)</code></a>
<dd>Executes all pending <code><a href="#finally">finally</a></code>
expressions, then the <code>VAL</code> of the global variable <code><a
href="#*Bye">*Bye</a></code> (should be a <code>prg</code>), closes all open
files, and exits the Pico Lisp interpreter. The process return value is
<code>cnt</code>, or 0 if the argument is missing or <code>NIL</code>.

<p><pre><code>
: (setq *Bye '((println 'Ok) (println 'bye)))
-> ((println 'Ok) (println 'bye))
: (bye)
Ok
bye
$
</code></pre>


<p><hr>
<h3><a name="c-foo">C</a></h3>

<p><dt><a name="caaar"><code>(caaar 'lst) -> any</code></a>
<dd>List access shortcut: Equivalent to <code>(car (car (car 'lst)))</code>.

<p><pre><code>
: (caaar '(((1 2) 3) 4))
-> 1
</code></pre>

<p><dt><a name="caadr"><code>(caadr 'lst) -> any</code></a>
<dd>List access shortcut: Equivalent to <code>(car (car (cdr 'lst)))</code>.

<p><pre><code>
: (caadr '(1 (2 3)))
-> 2
</code></pre>

<p><dt><a name="caar"><code>(caar 'lst) -> any</code></a>
<dd>List access shortcut: Equivalent to <code>(car (car 'lst))</code>.

<p><pre><code>
: (caar '((1 2) (3 4)))
-> 1
</code></pre>

<p><dt><a name="cadar"><code>(cadar 'lst) -> any</code></a>
<dd>List access shortcut: Equivalent to <code>(car (cdr (car 'lst)))</code>.

<p><pre><code>
: (cadar '((1 2 3)))
-> 2
</code></pre>

<p><dt><a name="cadddr"><code>(cadddr 'lst) -> any</code></a>
<dd>List access shortcut: Equivalent to <code>(car (cdr (cdr (cdr
'lst))))</code>, or the fourth element of <code>lst</code>.

<p><pre><code>
: (cadddr (1 2 3 4 5 6))
-> 4
</code></pre>

<p><dt><a name="caddr"><code>(caddr 'lst) -> any</code></a>
<dd>List access shortcut: Equivalent to <code>(car (cdr (cdr 'lst)))</code>, or
the third element of <code>lst</code>.

<p><pre><code>
: (caddr (1 2 3 4 5 6))
-> 3
</code></pre>

<p><dt><a name="cadr"><code>(cadr 'lst) -> any</code></a>
<dd>List access shortcut: Equivalent to <code>(car (cdr 'lst))</code>, or the
second element of <code>lst</code>.

<p><pre><code>
: (cadr (1 2 3 4 5 6))
-> 2
</code></pre>

<p><dt><a name="call"><code>(call 'any ..) -> flg</code></a>
<dd>Calls an external system command. The <code>any</code> arguments specify the
command and its arguments. Returns <code>T</code> if the command was executed
successfully.

<p><pre><code>
: (when (call 'test "-r" "file.l")  # Test if file exists and is readable
   (load "file.l")                  # Load it
   (call 'rm "file.l") )            # Remove it
</code></pre>

<p><dt><a name="car"><code>(car 'lst) -> any</code></a>
<dd>List access: Returns the first element of <code>lst</code>.

<p><pre><code>
: (car (1 2 3 4 5 6))
-> 1
</code></pre>

<p><dt><a name="case"><code>(case 'any (any1 . prg1) (any2 . prg2) ..) -> any</code></a>
<dd>Multi-way branch: <code>any</code> is evaluated and compared to the
<code>CAR</code> elements <code>anyN</code> of each clause. If one of them is a
list, <code>any</code> is in turn compared to all elements of that list.
<code>T</code> is a catch-all for any value. If a comparison succeeds,
<code>prgN</code> is executed, and the result returned. Otherwise
<code>NIL</code> is returned.

<p><pre><code>
: (case (char 66) ("A" (+ 1 2 3)) (("B" "C") "Bambi") ("D" (* 1 2 3)))
-> "Bambi"
</code></pre>

<p><dt><a name="catch"><code>(catch 'sym . prg) -> any</code></a>
<dd>Sets up the environment for a non-local jump with <code><a
href="#throw">throw</a></code>. <code>sym</code> is used by <code>throw</code>
as a jump label (with <code>T</code> being a catch-all for any label). If
<code>throw</code> is called during the execution of <code>prg</code>, the value
thrown is returned immediately. Otherwise, the result of <code>prg</code> is
returned. See also <code><a href="#finally">finally</a></code>.

<p><pre><code>
: (catch 'Ok (println 1) (throw 'Ok 999) (println 2))
1
-> 999
</code></pre>

<p><dt><a name="cd"><code>(cd 'any) -> sym</code></a>
<dd>Changes the current directory to <code>any</code>. The old directory is
returned on success, otherwise <code>NIL</code>. See also <code><a
href="#dir">dir</a></code> and <code><a href="#pwd">pwd</a></code>.

<p><pre><code>
: (when (cd "lib")
   (println (sum lines (dir)))
   (cd @) )
10955
</code></pre>

<p><dt><a name="cdaar"><code>(cdaar 'lst) -> any</code></a>
<dd>List access shortcut: Equivalent to <code>(cdr (car (car 'lst)))</code>.

<p><pre><code>
: (cdaar '(((1 2 3))))
-> (2 3)
</code></pre>

<p><dt><a name="cdadr"><code>(cdadr 'lst) -> any</code></a>
<dd>List access shortcut: Equivalent to <code>(cdr (car (cdr 'lst)))</code>.

<p><pre><code>
: (cdadr '((1 2) (3 4)))
-> (4)
</code></pre>

<p><dt><a name="cdar"><code>(cdar 'lst) -> any</code></a>
<dd>List access shortcut: Equivalent to <code>(cdr (car 'lst))</code>.

<p><pre><code>
: (cdar '((1 2) (3 4)))
-> (2)
</code></pre>

<p><dt><a name="cddar"><code>(cddar 'lst) -> any</code></a>
<dd>List access shortcut: Equivalent to <code>(cdr (cdr (car 'lst)))</code>.

<p><pre><code>
: (cddar '((1 2 3 4)))
-> (3 4)
</code></pre>

<p><dt><a name="cddddr"><code>(cddddr 'lst) -> any</code></a>
<dd>List access shortcut: Equivalent to <code>(cdr (cdr (cdr (cdr
'lst))))</code>. Returns all but the first four elements of <code>lst</code>.

<p><pre><code>
: (cddddr (1 2 3 4 5 6))
-> (5 6)
</code></pre>

<p><dt><a name="cdddr"><code>(cdddr 'lst) -> any</code></a>
<dd>List access shortcut: Equivalent to <code>(cdr (cdr (cdr 'lst)))</code>.
Returns all but the first three elements of <code>lst</code>.

<p><pre><code>
: (cdddr (1 2 3 4 5 6))
-> (4 5 6)
</code></pre>

<p><dt><a name="cddr"><code>(cddr 'lst) -> any</code></a>
<dd>List access shortcut: Equivalent to <code>(cdr (cdr 'lst))</code>. Returns
all but the first two elements of <code>lst</code>.

<p><pre><code>
: (cddr (1 2 3 4 5 6))
-> (3 4 5 6)
</code></pre>

<p><dt><a name="cdr"><code>(cdr 'lst) -> any</code></a>
<dd>List access: Returns all but the first element of <code>lst</code>.

<p><pre><code>
: (cdr (1 2 3 4 5 6))
-> (2 3 4 5 6)
</code></pre>

<p><dt><a name="chain"><code>(chain 'lst ..) -> lst</code></a>
<dd>Concatenates (destructively) one or several new list elements
<code>lst</code> to the end of the list in the current <code><a
href="#make">make</a></code> environment. This operation is efficient also for
long lists, because a pointer to the last element of the list is maintained.
<code>chain</code> returns the last linked argument. See also <code><a
href="#link">link</a></code> and <code><a href="#made">made</a></code>.

<p><pre><code>
: (make (chain (list 1 2 3) NIL (cons 4)) (chain (list 5 6)))
-> (1 2 3 4 5 6)
</code></pre>

<p><dt><a name="char"><code>(char) -> sym<br>
(char 'cnt) -> sym<br>
(char T) -> sym<br>
(char 'sym) -> cnt</code></a>
<dd>When called without arguments, the next character from the current input
stream is returned as a single-character transient symbol, or <code>NIL</code>
upon end of file. When called with a number <code>cnt</code>, a character with
the corresponding unicode value is returned. As a special case, <code>T</code>
is accepted to produce a byte value greater than any first byte in a unicode
character (used as a top value in comparisons). Otherwise, when called with a
symbol <code>sym</code>, the numeric unicode value of the first character of the
name of that symbol is returned. See also <code><a href="#peek">peek</a></code>,
<code><a href="#skip">skip</a></code>, <code><a href="#key">key</a></code>,
<code><a href="#line">line</a></code>, <code><a href="#till">till</a></code> and
<code><a href="#eof">eof</a></code>.

<p><pre><code>
: (char)                   # Read character from console
A                          # (typed 'A' and a space/return)
-> "A"
: (char 100)               # Convert unicode to symbol
-> "d"
: (char T)                 # Special case, catch all
-> # (not printable)
: (char "d")               # Convert symbol to unicode
-> 100
</code></pre>

<p><dt><a name="chop"><code>(chop 'any) -> lst</code></a>
<dd>Returns <code>any</code> as a list of single-character strings. If
<code>any</code> is <code>NIL</code> or a symbol with no name, <code>NIL</code>
is returned. A list argument is returned unchanged.

<p><pre><code>
: (chop 'car)
-> ("c" "a" "r")
: (chop "Hello")
-> ("H" "e" "l" "l" "o")
</code></pre>

<p><dt><a name="circ"><code>(circ 'any ..) -> lst</code></a>
<dd>Produces a circular list of all <code>any</code> arguments by <code><a
href="#cons">cons</a></code>ing them to a list and then connecting the
<code>CDR</code> of the last cell to the first cell. See also <code><a
href="#list">list</a></code>.

<p><pre><code>
: (circ 'a 'b 'c)
-> (a b c .)
</code></pre>

<p><dt><a name="clip"><code>(clip 'lst) -> lst</code></a>
<dd>Returns a copy of <code>lst</code> with all white space characters or
<code>NIL</code> elements removed from both sides. See also <code><a
href="#trim">trim</a></code>.

<p><pre><code>
: (clip '(NIL 1 NIL 2 NIL))
-> (1 NIL 2)
: (clip '(" " a " " b " "))
-> (a " " b)
</code></pre>

<p><dt><a name="close"><code>(close 'cnt) -> flg</code></a>
<dd>Closes a file descriptor <code>cnt</code>, and returns non-<code>NIL</code>
when successful. See also <code><a href="#open">open</a></code>, <code><a
href="#listen">listen</a></code> and <code><a
href="#connect">connect</a></code>.

<p><pre><code>
: (close 2)                            # Close standard error
-> T
</code></pre>

<p><dt><a name="cnt"><code>(cnt 'fun 'lst ..) -> cnt</code></a>
<dd>Applies <code>fun</code> to each element of <code>lst</code>. When
additional <code>lst</code> arguments are given, their elements are also passed
to <code>fun</code>. Returns the count of non-<code>NIL</code> values returned
from <code>fun</code>.

<p><pre><code>
: (cnt cdr '((1 . T) (2) (3 4) (5)))
-> 2
</code></pre>

<p><dt><a name="commit"><code>(commit ['any] [exe1] [exe2]) -> flg</code></a>
<dd>Closes a transaction, by writing all new or modified external symbols to the
database, and by removing all deleted symbols from the database. For nested
transactions, only the changes since the last call to <code><a
href="#begin">begin</a></code> are taken into account. A non-<code>NIL</code>
<code>any</code> argument forces modifications of the current transaction level
to be written out, even if this is not the top level. When <code>any</code> is
anything other than <code>T</code>, it is implicitly sent (with all modified
objects) via the <code><a href="#tell">tell</a></code> mechanism to all family
members. If <code>exe1</code> or <code>exe2</code> are given, they are executed
as pre- or post-expressions while the database is <code><a
href="#lock">lock</a></code>ed and <code><a
href="#protect">protect</a></code>ed. Returns <code>T</code> when the topmost
transaction is closed. See also <code><a href="#rollback">rollback</a></code>.

<p><pre><code>
: (pool "db")
-> T
: (put '{1} 'str "Hello")
-> "Hello"
: (commit)
-> T
</code></pre>

<p><dt><a name="con"><code>(con 'lst 'any) -> any</code></a>
<dd>Connects <code>any</code> to the first cell of <code>lst</code>, by
(destructively) storing <code>any</code> in the <code>CDR</code> of
<code>lst</code>.

<p><pre><code>
: (setq C (1 . a))
-> (1 . a)
: (con C '(b c d))
-> (b c d)
: C
-> (1 b c d)
</code></pre>

<p><dt><a name="conc"><code>(conc 'lst ..) -> lst</code></a>
<dd>Concatenates all argument lists (destructively). See also <code><a
href="#append">append</a></code>.

<p><pre><code>
: (setq  A (1 2 3)  B '(a b c))
-> (a b c)
: (conc A B)                        # Concatenate lists in 'A' and 'B'
-> (1 2 3 a b c)
: A
-> (1 2 3 a b c)                    # Side effect: List in 'A' is modified!
</code></pre>

<p><dt><a name="cond"><code>(cond (('any1 . prg1) ('any2 . prg2) ..)) -> any</code></a>
<dd>Multi-way conditional: If any of the <code>anyN</code> conditions evaluates
to non-<code>NIL</code>, <code>prgN</code> is executed and the result returned.
Otherwise (all conditions evaluate to <code>NIL</code>), <code>NIL</code> is
returned. See also <code><a href="#nond">nond</a></code>, <code><a
href="#if">if</a></code>, <code><a href="#if2">if2</a></code> and <code><a
href="#when">when</a></code>.

<p><pre><code>
: (cond
   ((= 3 4) (println 1))
   ((= 3 3) (println 2))
   (T (println 3)) )
2
-> 2
</code></pre>

<p><dt><a name="connect"><code>(connect 'any 'cnt) -> cnt | NIL</code></a>
<dd>Tries to establish a TCP/IP connection to a server listening at host
<code>any</code>, port <code>cnt</code>. <code>any</code> may be either a
hostname or a standard internet address in numbers-and-dots notation. Returns a
socket descriptor <code>cnt</code>, or <code>NIL</code> if the connection cannot
be established. See also <code><a href="#listen">listen</a></code> and <code><a
href="#nagle">nagle</a></code>.

<p><pre><code>
: (connect "localhost" 4444)
-> 3
</code></pre>

<p><dt><a name="cons"><code>(cons 'any 'any) -> lst</code></a>
<dd>Constructs a new list cell with the first argument in the <code>CAR</code>
and the second argument in the <code>CDR</code>.

<p><pre><code>
: (cons 1 2)
-> (1 . 2)
: (cons 'a '(b c d))
-> (a b c d)
: (cons '(a b) '(c d))
-> ((a b) c d)
</code></pre>

<p><dt><a name="copy"><code>(copy 'any) -> any</code></a>
<dd>Copies the argument <code>any</code>. For lists, the top level cells are
copied, while atoms are returned unchanged.

<p><pre><code>
: (=T (copy T))               # Atoms are not copied
-> T
: (setq L (1 2 3))
-> (1 2 3)
: (== L L)
-> T
: (== L (copy L))             # The copy is not identical to the original
-> NIL
: (= L (copy L))              # But the copy is equal to the original
-> T
</code></pre>

<p><dt><a name="ctl"><code>(ctl 'sym . prg) -> any</code></a>
<dd>Waits until a write (exclusive) lock (or a read (shared) lock if the first
character of <code>sym</code> is "<code>+</code>") can be set on the file
<code>sym</code>, then executes <code>prg</code> and releases the lock. If the
files does not exist, it will be created. When <code>sym</code> is
<code>NIL</code>, a shared lock is tried on the current innermost I/O channel,
and when it is <code>T</code>, an exclusive lock is tried instead. See also
<code><a href="#in">in</a></code>, <code><a href="#pipe">pipe</a></code> and
<code><a href="#out">out</a></code>. Note: It is not recommended to lock a file
by name and then do I/O on the same file, as this may give unexpected results on
some operating systems.

<p><pre><code>
$ echo 9 >count                           # Write '9' to file "count"
$ ./p dbg.l
: (ctl ".ctl"                             # Exclusive control, using ".ctl"
   (in "count"
      (let Cnt (read)                     # Read '9'
         (out "count"
            (println (dec Cnt)) ) ) ) )   # Write '8'
-> 8
:
$ cat count                               # Check "count"
8
</code></pre>

<p><dt><a name="ctty"><code>(ctty 'sym|pid) -> flg</code></a>
<dd>When called with a symbolic argument, <code>ctty</code> changes the current
TTY device to <code>sym</code>. Otherwise, the local console is prepared for
serving the remote Pico Lisp process <code>pid</code>. See also <code><a
href="#raw">raw</a></code>.

<p><pre><code>
: (ctty "/dev/tty")
-> T
</code></pre>

<p><dt><a name="cut"><code>(cut 'cnt 'var) -> lst</code></a>
<dd>Pops the first <code>cnt</code> elements (<code>CAR</code>) from the stack
in <code>var</code>. See also <code><a href="#pop">pop</a></code> and <code><a
href="#del">del</a></code>.

<p><pre><code>
: (setq S '(1 2 3 4 5 6 7 8))
-> (1 2 3 4 5 6 7 8)
: (cut 3 'S)
-> (1 2 3)
: S
-> (4 5 6 7 8)
</code></pre>


<p><hr>
<h3><a name="d-foo">D</a></h3>

<p><dt><a name="date"><code>(date ['T]) -> dat<br>
(date 'dat) -> (y m d)<br>
(date 'y 'm 'd) -> dat | NIL<br>
(date '(y m d)) -> dat | NIL</code></a>
<dd>Calculates a calendar date, represented as the number of days since first of
March in the year 0. When called without arguments, the current date is
returned. When called with a <code>T</code> argument, the current Coordinated
Universal Time (UTC) is returned. When called with a single number
<code>dat</code>, it is taken as a date and a list with the corresponding year,
month and day is returned. When called with three numbers (or a list of three
numbers) for the year, month and day, the corresponding date is returned (or
<code>NIL</code> if they do not represent a legal date). See also <code><a
href="#time">time</a></code>.

<p><pre><code>
: (date)                         # Today
-> 730589
: (date 2000 6 12)               # 12-06-2000
-> 730589
: (date 2000 22 5)               # Illegal date
-> NIL
: (date (date))                  # Today's year, month and day
-> (2000 6 12)
: (- (date) (date 2000 1 1))     # Number of days since first of January
-> 163
</code></pre>

<p><dt><a name="dbck"><code>(dbck ['cnt] 'flg) -> any</code></a>
<dd>Performs a low-level integrity check of the current (or <code>cnt</code>'th)
database file, and returns <code>NIL</code> (or the number of blocks and symbols
if <code>flg</code> is non-<code>NIL</code>) if everything seems correct.
Otherwise, a string indicating an error is returned. As a side effect, possibly
unused blocks (as there might be when a <code><a
href="#rollback">rollback</a></code> is done before <code><a
href="#commit">commit</a></code>ing newly allocated (<code><a
href="#new">new</a></code>) external symbols) are appended to the free list.

<p><pre><code>
: (pool "db")
-> T
: (dbck)
-> NIL
</code></pre>

<p><dt><a name="de"><code>(de sym . any) -> sym</code></a>
<dd>Assigns a definition to the <code>sym</code> argument, by setting its
<code>VAL</code> to the <code>any</code> argument. If the symbol has already
another value, a "redefined" message is issued. <code>de</code> is the standard
way to define a function.

<p><pre><code>
: (de foo (X Y) (* X (+ X Y)))  # Define a function
-> foo
: (foo 3 4)
-> 21

: (de *Var . 123)  # Define a variable value
: *Var
-> 123
</code></pre>

<p><dt><a name="debug"><code>(debug 'sym) -> T<br>
(debug 'sym 'cls) -> T<br>
(debug '(sym . cls)) -> T</code></a>
<dd>Inserts a <code><a href="#!">!</a></code> breakpoint function call at the
beginning and all top-level expressions of the function or method body of
<code>sym</code>, to allow a stepwise execution. Typing <code>(d)</code> at a
breakpoint will also debug the current subexpression, and <code>(<a
href="#e">e</a>)</code> will evaluate the current subexpression. The current
subexpression is stored in the global variable <code><a href="#^">^</a></code>.
See also <code><a href="#*Dbg">*Dbg</a></code>.

<p><pre><code>
: (de tst (N)                    # Define tst
   (println (+ 3 N)) )
-> tst
: (debug 'tst)                   # Set breakpoints
-> T
: (pp 'tst)
(de tst (N)
   (! println (+ 3 N)) )         # Breakpoint '!'
-> tst
: (tst 7)                        # Execute
(println (+ 3 N))                # Stopped at beginning of 'tst'
! (d)                            # Debug subexpression
-> T
!                                # Continue
(+ 3 N)                          # Stopped in subexpression
! N                              # Inspect variable 'N'
-> 7
!                                # Continue
10                               # Output of print statement
-> 10                            # Done
: (unbug 'tst)
-> T
: (pp 'tst)                      # Restore to original
(de tst (N)
   (println (+ 3 N)) )
-> tst
</code></pre>

<p><dt><a name="dec"><code>(dec 'num) -> num<br>
(dec 'var ['num]) -> num</code></a>
<dd>The first form returns the value of <code>num</code> decremented by 1. The
second form decrements the <code>VAL</code> of <code>var</code> by 1, or by
<code>num</code>. <code>(dec 'num)</code> is equivalent to <code>(- 'num
1)</code> and <code>(dec 'var)</code> is equivalent to <code>(set 'var (- var
1))</code>.

<p><pre><code>
: (dec -1)
-> -2
: (dec 7)
-> 6
: (setq N 7)
-> 7
: (dec 'N)
-> 6
: (dec 'N 3)
-> 3
</code></pre>

<p><dt><a name="def"><code>(def 'sym 'any) -> sym<br>
(def 'sym 'sym 'any) -> sym</code></a>
<dd>The first form assigns a definition to the first <code>sym</code> argument,
by setting its <code>VAL</code>'s to <code>any</code>. The second form defines a
property value <code>any</code> for the second argument's <code>sym</code> key.
If any of these values existed and was changed in the process, a "redefined"
message is issued.

<p><pre><code>
: (def 'b '((X Y) (* X (+ X Y))))
-> b
: (def 'b 999)
# b redefined
-> b
</code></pre>

<p><dt><a name="default"><code>(default sym 'any ..) -> any</code></a>
<dd>Stores new values <code>any</code> in the <code>sym</code> arguments only if
their current values are <code>NIL</code>. Otherwise, their values are left
unchanged. <code>default</code> is used typically in functions to initialize
optional arguments.

<p><pre><code>
: (de foo (A B)               # Function with two optional arguments
   (default  A 1  B 2)        # The default values are 1 and 2
   (list A B) )
-> foo
: (foo 333 444)               # Called with two arguments
-> (333 444)
: (foo 333)                   # Called with one arguments
-> (333 2)
: (foo)                       # Called without arguments
-> (1 2)
</code></pre>

<p><dt><a name="del"><code>(del 'any 'var) -> any</code></a>
<dd>Deletes <code>any</code> from the list in the value of <code>var</code>.
<code>(del 'any 'var)</code> is equivalent to <code>(set 'var (delete 'any
var))</code>. See also <code><a href="#delete">delete</a></code>, <code><a
href="#cut">cut</a></code> and <code><a href="#pop">pop</a></code>.

<p><pre><code>
: (setq S '((a b c) (d e f)))
-> ((a b c) (d e f))
: (del '(d e f) 'S)
-> ((a b c))
: (del 'b S)
-> (a c)
</code></pre>

<p><dt><a name="delete"><code>(delete 'any 'lst) -> lst</code></a>
<dd>Deletes <code>any</code> from <code>lst</code>. If <code>any</code> is
contained more than once in <code>lst</code>, only the first occurrence is
deleted. See also <code><a href="#delq">delq</a></code>.

<p><pre><code>
: (delete 2 (1 2 3))
-> (1 3)
: (delete (3 4) '((1 2) (3 4) (5 6) (3 4)))
-> ((1 2) (5 6) (3 4))
</code></pre>

<p><dt><a name="delq"><code>(delq 'any 'lst) -> lst</code></a>
<dd>Deletes <code>any</code> from <code>lst</code>. If <code>any</code> is
contained more than once in <code>lst</code>, only the first occurrence is
deleted. <code><a href="#==">==</a></code> is used for comparison (pointer
equality). See also <code><a href="#delete">delete</a></code>, <code><a
href="#asoq">asoq</a></code>, <code><a href="#memq">memq</a></code> and <code><a
href="#mmeq">mmeq</a></code>.

<p><pre><code>
: (delq 'b '(a b c))
-> (a c)
: (delq 2 (1 2 3))
-> (1 2 3)
</code></pre>

<p><dt><a name="die"><code>(die 'cnt . prg) -> any</code></a>
<dd> If the execution of <code>prg</code> does not finish within
<code>cnt</code> seconds, the current process will receive a SIGTERM signal. See
also <code><a href="#bye">bye</a></code> and <code><a
href="#protect">protect</a></code>.

<p><pre><code>
: (die 6 (finally (msg 'Bye) (loop)))
Bye
$
</code></pre>

<p><dt><a name="diff"><code>(diff 'lst 'lst) -> lst</code></a>
<dd>Returns the difference of the <code>lst</code> arguments. See also <code><a
href="#sect">sect</a></code>.

<p><pre><code>
: (diff (1 2 3 4 5) (2 4))
-> (1 3 5)
: (diff (1 2 3) (1 2 3))
-> NIL
</code></pre>

<p><dt><a name="dir"><code>(dir ['any]) -> lst</code></a>
<dd>Returns a list of all filenames in the directory <code>any</code>. Names
starting with a dot '<code>.</code>' are ignored. See also <code><a
href="#cd">cd</a></code> and <code><a href="#info">info</a></code>.

<p><pre><code>
: (filter '((F) (tail '(. c) (chop F))) (dir "src/"))
-> ("main.c" "subr.c" "gc.c" "io.c" "big.c" "sym.c" "tab.c" "flow.c" ..
</code></pre>

<p><dt><a name="dm"><code>(dm sym . fun) -> sym<br>
(dm (sym . cls) . fun) -> sym<br>
(dm (sym sym [. cls]) . fun) -> sym</code></a>
<dd>Defines a method for the message <code>sym</code> in the current class,
implicitly given by the value of the global variable <code>*Class</code>, or -
in the second form - for the explicitly given class <code>cls</code>. In the
third form, the class object is obtained by <code><a
href="#get">get</a></code>ing <code>sym</code> from <code>*Class</code> (or
<code>cls</code> if given).

<p><pre><code>
: (dm start> ()
   (super)
   (mapc 'start> (: fields))
   (mapc 'start> (: arrays)) )
</code></pre>

<p><dt><a name="do"><code>(do 'flg|num ['any | (NIL 'any . prg) | (T 'any . prg) ..]) -> any</code></a>
<dd>Counted loop with multiple conditional exits: The body is executed at most
<code>num</code> times (or never (if the first argument is <code>NIL</code>), or
an infinite number of times (if the first argument is <code>T</code>)). If a
clause has <code>NIL</code> or <code>T</code> as its <code>CAR</code>, the
clause's second element is evaluated as a condition and - if the result is
<code>NIL</code> or non-<code>NIL</code>, respectively - the <code>prg</code> is
executed and the result returned. Otherwise (if count drops to zero), the result
of the last expression is returned. See also <code><a
href="#loop">loop</a></code> and <code><a href="#for">for</a></code>.

<p><pre><code>
: (do 4 (printsp 'Ok))
Ok Ok Ok Ok -> Ok
: (do 4 (printsp 'Ok) (T (= 3 3) (printsp 'done)))
Ok done -> done
</code></pre>


<p><hr>
<h3><a name="e-foo">E</a></h3>

<p><dt><a name="e"><code>(e . prg) -> any</code></a>
<dd>Used in a breakpoint. Evaluates <code>prg</code> in the execution
environment, or the currently executed expression if <code>prg</code> is not
given. See also <code><a href="#debug">debug</a></code>, <code><a
href="#!">!</a></code>, <code><a href="#^">^</a></code> and <code><a
href="#*Dbg">*Dbg</a></code>.

<p><pre><code>
: (! + 3 4)
(+ 3 4)
! (e)
-> 7
</code></pre>

<p><dt><a name="echo"><code>(echo ['cnt ['cnt]] | ['sym ..]) -> sym</code></a>
<dd>Reads the current input channel, and writes to the current output channel.
If <code>cnt</code> is given, only that many bytes are actually echoed. In case
of two <code>cnt</code> arguments, the first one specifies the number of bytes
to skip in the input stream. Otherwise, if one or more <code>sym</code>
arguments are given, the echo process stops as soon as one of the symbol's names
is encountered in the input stream (in that case, the name will be read (and
returned), but not written). Returns non-<code>NIL</code> if the operation was
successfully completed.

<p><pre><code>
: (in "x.l" (echo))                    # Display file on console
 ..

: (out "x2.l" (in "x.l" (echo)))       # Copy file "x.l" to "x2.l"
</code></pre>

<p><dt><a name="env"><code>(env ['lst] | ['sym 'val] ..) -> lst</code></a>
<dd>Return a list of symbol-value pairs of all dynamically bound symbols if
called without arguments, or of the symbols in <code>lst</code>, or the
explicitly given <code>sym</code>-<code>val</code> pairs. See also <code><a
href="#stk">stk</a></code>, <code><a href="#bind">bind</a></code> and <code><a
href="#job">job</a></code>.

<p><pre><code>
: (env)
-> NIL
: (let (A 1 B 2) (env))
-> ((A . 1) (B . 2))
: (let (A 1 B 2) (env '(A B)))
-> ((B . 2) (A . 1))
: (let (A 1 B 2) (env 'X 7 '(A B) 'Y 8))
-> ((Y . 8) (B . 2) (A . 1) (X . 7))
</code></pre>

<p><dt><a name="eof"><code>(eof ['flg]) -> flg</code></a>
<dd>Returns the end-of-file status of the current input channel. If
<code>flg</code> is non-<code>NIL</code>, the channel's status is forced to
end-of-file, so that the next call to <code>eof</code> will return
<code>T</code>, and calls to <code><a href="#char">char</a></code>, <code><a
href="#peek">peek</a></code>, <code><a href="#line">line</a></code>, <code><a
href="#from">from</a></code>, <code><a href="#till">till</a></code>, <code><a
href="#read">read</a></code> or <code><a href="#skip">skip</a></code> will
return <code>NIL</code>. Note that <code>eof</code> <i>cannot</i> be used with
the binary <code><a href="#rd">rd</a></code> function.

<p><pre><code>
: (in "file" (until (eof) (println (line T))))
...
</code></pre>

<p><dt><a name="eval"><code>(eval 'any ['cnt]) -> any</code></a>
<dd>Evaluates <code>any</code>. Note that because of the standard argument
evaluation, <code>any</code> is actually evaluated twice. If a binding
environment offset <code>cnt</code> is given, the second evaluation takes place
in the corresponding environment. See also <code><a href="#run">run</a></code>
and <code><a href="#up">up</a></code>.

<p><pre><code>
: (eval (list '+ 1 2 3))
-> 6
: (setq X 'Y  Y 7)
-> 7
: X
-> Y
: Y
-> 7
: (eval X)
-> 7
</code></pre>

<p><dt><a name="extQ"><code>(ext? 'any) -> sym | NIL</code></a>
<dd>Returns the argument <code>any</code> when it is an existing external
symbol, otherwise <code>NIL</code>. See also <code><a
href="#symQ">sym?</a></code>, <code><a href="#boxQ">box?</a></code>, <code><a
href="#strQ">str?</a></code>, <code><a href="#extern">extern</a></code> and
<code><a href="#lieu">lieu</a></code>.

<p><pre><code>
: (ext? *DB)
-> {1}
: (ext? 'abc)
-> NIL
: (ext? "abc")
-> NIL
: (ext? 123)
-> NIL
</code></pre>

<p><dt><a name="extern"><code>(extern 'sym) -> sym | NIL</code></a>
<dd>Creates or finds an external symbol. If a symbol with the name
<code>sym</code> is already extern, it is returned. Otherwise, a new external
symbol is returned. <code>NIL</code> is returned if <code>sym</code> does not
exist in the database. See also <code><a href="#intern">intern</a></code> and
<code><a href="#extQ">ext?</a></code>.

<p><pre><code>
: (extern "A1b")
-> {A1b}
: (extern "{A1b}")
-> {A1b}
</code></pre>

<p><dt><a name="extra"><code>(extra ['any ..]) -> any</code></a>
<dd>Can only be used inside methods. Sends the current message to the current
object <code>This</code>, this time starting the search for a method at the
remaining branches of the inheritance tree of the class where the current method
was found.

<p><pre><code>
(dm key> (C)            # 'key>' method of the '+Uppc' class
   (uppc (extra C)) )   # Convert 'key>' of extra classes to upper case
</code></pre>


<p><hr>
<h3><a name="f-foo">F</a></h3>

<p><dt><a name="fifo"><code>(fifo 'var ['any]) -> any</code></a>
<dd>Implements a first-in-first-out structure using a circular list. When called
with an <code>any</code> argument, it will be concatenated to end of the
structure. Otherwise, the first element is removed from the structure and
returned. See also <code><a href="#queue">queue</a></code>, <code><a
href="#push">push</a></code>, <code><a href="#pop">pop</a></code>, <code><a
href="#rot">rot</a></code> and <code><a href="#circ">circ</a></code>.

<p><pre><code>
: (fifo 'X 1)
-> 1
: (fifo 'X 2)
-> 2
: (fifo 'X 3)
-> 3
: X
-> (3 1 2 .)
: (fifo 'X)
-> 1
: (fifo 'X)
-> 2
: X
-> (3 .)
</code></pre>

<p><dt><a name="fill"><code>(fill 'any ['sym|lst]) -> any</code></a>
<dd>Fills a pattern <code>any</code>, by substituting <code>sym</code>, or all
symbols in <code>lst</code>, or - if no second argument is given - each pattern
symbol in <code>any</code> (see <code><a href="#patQ">pat?</a></code>), with its
current value. In that case, <code>@</code> itself is not considered a pattern
symbol. See also <code><a href="#match">match</a></code>.

<p><pre><code>
: (setq  @X 1234  @Y (1 2 3 4))
-> (1 2 3 4)
: (fill '@X)
-> 1234
: (fill '(a b (c @X) ((@Y . d) e)))
-> (a b (c 1234) (((1 2 3 4) . d) e))
: (let X 2 (fill (1 X 3) 'X))
-> (1 2 3)
</code></pre>

<p><dt><a name="filter"><code>(filter 'fun 'lst ..) -> lst</code></a>
<dd>Applies <code>fun</code> to each element of <code>lst</code>. When
additional <code>lst</code> arguments are given, their elements are also passed
to <code>fun</code>. Returns a list of all elements of <code>lst</code> where
<code>fun</code> returned non-<code>NIL</code>. See also <code><a
href="#fish">fish</a></code>.

<p><pre><code>
: (filter num? (1 A 2 (B) 3 CDE))
-> (1 2 3)
</code></pre>

<p><dt><a name="fin"><code>(fin 'any) -> num|sym</code></a>
<dd>Returns <code>any</code> if it is an atom, otherwise the <code>CDR</code> of
its last cell. See also <code><a href="#last">last</a></code> and <code><a
href="#tail">tail</a></code>.

<p><pre><code>
: (fin 'a)
-> a
: (fin '(a . b))
-> b
: (fin '(a b . c))
-> c
: (fin '(a b c))
-> NIL
</code></pre>

<p><dt><a name="finally"><code>(finally exe . prg) -> any</code></a>
<dd><code>prg</code> is executed, then <code>exe</code> is evaluated, and the
result of <code>prg</code> is returned. <code>exe</code> will also be evaluated
if <code>prg</code> does not terminate normally due to a runtime error or a call
to <code><a href="#throw">throw</a></code>. See also <code><a
href="#bye">bye</a></code>, <code><a href="#catch">catch</a></code>, <code><a
href="#quit">quit</a></code> and <code><a href="#errors">Error
Handling</a></code>.

<p><pre><code>
: (finally (prinl "Done!")
   (println 123)
   (quit)
   (println 456) )
123
Done!
: (catch 'A
   (finally (prinl "Done!")
      (println 1)
      (throw 'A 123)
      (println 2) ) )
1
Done!
-> 123
</code></pre>

<p><dt><a name="find"><code>(find 'fun 'lst ..) -> any</code></a>
<dd>Applies <code>fun</code> to successive elements of <code>lst</code> until
non-<code>NIL</code> is returned. Returns that element, or <code>NIL</code> if
<code>fun</code> did not return non-<code>NIL</code> for any element of
<code>lst</code>. When additional <code>lst</code> arguments are given, their
elements are also passed to <code>fun</code>. See also <code><a
href="#seek">seek</a></code>, <code><a href="#pick">pick</a></code>.

<p><pre><code>
: (find pair (1 A 2 (B) 3 CDE))
-> (B)
: (find '((A B) (> A B)) (1 2 3 4 5 6) (6 5 4 3 2 1))
-> 4
: (find > (1 2 3 4 5 6) (6 5 4 3 2 1))  # shorter
-> 4
</code></pre>

<p><dt><a name="fish"><code>(fish 'fun 'any) -> lst</code></a>
<dd>Applies <code>fun</code> to each element - and recursively to all sublists -
of <code>lst</code>. Returns a list of all items where <code>fun</code> returned
non-<code>NIL</code>. See also <code><a href="#filter">filter</a></code>.

<p><pre><code>
: (fish gt0 '(a -2 (1 b (-3 c 2)) 3 d -1))
-> (1 2 3)
: (fish sym? '(a -2 (1 b (-3 c 2)) 3 d -1))
-> (a b c d)
</code></pre>

<p><dt><a name="flgQ"><code>(flg? 'any) -> flg</code></a>
<dd>Returns <code>T</code> when the argument <code>any</code> is either
<code>NIL</code> or <code>T</code>. See also <code><a
href="#bool">bool</a></code>. <code>(flg? X)</code> is equivalent to <code>(or
(not X) (=T X))</code>.

<p><pre><code>
: (flg? (= 3 3))
-> T
: (flg? (= 3 4))
-> T
: (flg? (+ 3 4))
-> NIL
</code></pre>

<p><dt><a name="flip"><code>(flip 'lst) -> lst</code></a>
<dd>Returns <code>lst</code> (destructively) reversed. See also <code><a
href="#reverse">reverse</a></code>.

<p><pre><code>
: (flip (1 2 3 4))
-> (4 3 2 1)
</code></pre>

<p><dt><a name="flush"><code>(flush) -> flg</code></a>
<dd>Flushes the current output stream by writing all buffered data. A call to
<code>flush</code> for standard output is done automatically before a call to
<code><a href="#key">key</a></code>. Returns <code>T</code> when successful. See
also <code><a href="#rewind">rewind</a></code>.

<p><pre><code>
: (flush)
-> T
</code></pre>

<p><dt><a name="fold"><code>(fold 'any ['cnt]) -> sym</code></a>
<dd>Folding to a canonical form: If <code>any</code> is not a symbol,
<code>NIL</code> is returned. Otherwise, a new transient symbol with all digits
and all letters of <code>any</code>, converted to lower case, is returned. If
the <code>cnt</code> argument is given, the result is truncated to that length
(or not truncated if <code>cnt</code> is zero). Otherwise <code>cnt</code>
defaults to 24. See also <code><a href="#lowc">lowc</a></code>.

<p><pre><code>
: (fold " 1A 2-b/3")
-> "1a2b3"
: (fold " 1A 2-B/3" 3)
-> "1a2"
</code></pre>

<p><dt><a name="for"><code>(for sym|(sym2 . sym) 'lst ['any | (NIL 'any . prg) | (T 'any . prg) ..]) -> any<br>
(for (sym|(sym2 . sym) 'any1 'any2 [. prg]) ['any | (NIL 'any . prg) | (T 'any . prg) ..]) -> any</code></a>
<dd>Conditional loop with local variable(s) and multiple conditional exits: In
the first form, the value of <code>sym</code> is saved, <code>sym</code> is
subsequently bound to the elements of <code>lst</code>, and the body is executed
each time. In the second form, the value of <code>sym</code> is saved, and
<code>sym</code> is bound to <code>any1</code>. If <code>sym2</code> is given,
it is treated as a counter variable, first bound to 1 and then incremented for
each execution of the body. While the condition <code>any2</code> evaluates to
non-<code>NIL</code>, the body is repeatedly executed and, if <code>prg</code>
is given, <code>sym</code> is re-bound to the result of its evaluation. If a
clause has <code>NIL</code> or <code>T</code> as its <code>CAR</code>, the
clause's second element is evaluated as a condition and - if the result is
<code>NIL</code> or non-<code>NIL</code>, respectively - the <code>prg</code> is
executed and the result returned. If the body is never executed,
<code>NIL</code> is returned. See also <code><a href="#do">do</a></code> and
<code><a href="#loop">loop</a></code>.

<p><pre><code>
: (for (N 1 (>= 8 N) (inc N)) (printsp N))
1 2 3 4 5 6 7 8 -> 8
: (for (L (1 2 3 4 5 6 7 8) L) (printsp (pop 'L)))
1 2 3 4 5 6 7 8 -> 8
: (for X (1 a 2 b) (printsp X))
1 a 2 b -> b
: (for ((I . L) '(a b c d e f) L (cddr L)) (println I L))
1 (a b c d e f)
2 (c d e f)
3 (e f)
-> (e f)
: (for (I . X) '(a b c d e f) (println I X))
1 a
2 b
3 c
4 d
5 e
6 f
-> f
</code></pre>

<p><dt><a name="fork"><code>(fork) -> pid | NIL</code></a>
<dd>Forks a child process. Returns <code>NIL</code> in the child, and the
child's process ID <code>pid</code> in the parent. In the child, the
<code>VAL</code> of the global variable <code><a href="#*Fork">*Fork</a></code>
(should be a <code>prg</code>) is executed. See also <code><a
href="#pipe">pipe</a></code> and <code><a href="#tell">tell</a></code>.

<p><pre><code>
: (unless (fork) (do 5 (println 'Ok) (wait 1000)) (bye))
-> NIL
Ok                                              # Child's output
: Ok
Ok
Ok
Ok
</code></pre>

<p><dt><a name="format"><code>(format 'num ['cnt ['sym1 ['sym2]]]) -> sym<br>
(format 'sym ['cnt ['sym1 ['sym2]]]) -> num</code></a>
<dd>Converts a number <code>num</code> to a string, or a string <code>sym</code>
to a number. In both cases, optionally a precision <code>cnt</code>, a
decimal-separator <code>sym1</code> and a thousands-separator <code>sym2</code>
can be supplied. Returns <code>NIL</code> if the conversion is unsuccessful. See
also <code><a href="#num-io">Numbers</a></code>.

<p><pre><code>
: (format 123456789)                   # Integer conversion
-> "123456789"
: (format 123456789 2)                 # Fixed point
-> "1234567.89"
: (format 123456789 2 ",")             # Comma as decimal-separator
-> "1234567,89"
: (format 123456789 2 "," ".")         # and period as thousands-separator
-> "1.234.567,89"
:
: (format "123456789")                 # String to number
-> 123456789
: (format "1234567.89" 4)              # scaled to four digits
-> 12345678900
: (format "1.234.567,89")              # separators not recognized
-> NIL
: (format "1234567,89" 4 ",")
-> 12345678900
: (format "1.234.567,89" 4 ",")        # thousands-separator not recognized
-> NIL
: (format "1.234.567,89" 4 "," ".")
-> 12345678900
</code></pre>

<p><dt><a name="free"><code>(free 'cnt) -> (sym . lst)</code></a>
<dd>Returns, for the <code>cnt</code>'th database file, the next available
symbol <code>sym</code> (i.e. the first symbol greater than any symbol in the
database), and the list <code>lst</code> of free symbols. See also <code><a
href="#seq">seq</a></code>, <code><a href="#zap">zap</a></code> and <code><a
href="#dbck">dbck</a></code>.

<p><pre><code>
: (pool "x")      # A new database
-> T
: (new T)         # Create a new symbol
-> {2}
: (new T)         # Create another symbol
-> {3}
: (commit)        # Commit changes
-> T
: (zap '{2})      # Delete the first symbol
-> {2}
: (free 1)        # Show free list
-> ({4})          # {3} was the last symbol allocated
: (commit)        # Commit the deletion of {2}
-> T
: (free 1)        # Now {2} is in the free list
-> ({4} {2})
</code></pre>

<p><dt><a name="from"><code>(from 'any ..) -> sym</code></a>
<dd>Skips the current input channel until one of the strings <code>any</code> is
found, and starts subsequent reading from that point. The found <code>any</code>
argument, or <code>NIL</code> (if none is found) is returned. See also <code><a
href="#till">till</a></code> and <code><a href="#echo">echo</a></code>.

<p><pre><code>
: (and (from "val='") (till "'" T))
test val='abc'
-> "abc"
</code></pre>

<p><dt><a name="funQ"><code>(fun? 'any) -> any</code></a>
<dd>Returns <code>NIL</code> when the argument <code>any</code> is neither a
number suitable for a code-pointer, nor a list suitable for a lambda expression
(function). Otherwise a number is returned for a code-pointer, <code>T</code>
for a function without arguments, and a single formal parameter or a list of
formal parameters for a function.

<p><pre><code>
: (fun? 1000000000)              # Might be a code pointer
-> 1000000000
: (fun? 100000000000000)         # Too big for a code pointer
-> NIL
: (fun? 1000000001)              # Cannot be a code pointer (odd)
-> NIL
: (fun? '((A B) (* A B)))        # Lambda expression
-> (A B)
: (fun? '((A B) (* A B) . C))    # Not a lambda expression
-> NIL
: (fun? '(1 2 3 4))              # Not a lambda expression
-> NIL
: (fun? '((A 2 B) (* A B)))      # Not a lambda expression
-> NIL
</code></pre>


<p><hr>
<h3><a name="g-foo">G</a></h3>

<p><dt><a name="gc"><code>(gc ['cnt]) -> cnt | NIL</code></a>
<dd>Forces a garbage collection. When <code>cnt</code> is given, so many
millions of free cells are reserved, increasing the heap size if necessary.

<p><pre><code>
: (gc)
-> NIL
: (stat)
2 3%
-> 53299
: (gc 4)
-> 4
: (stat)
5 1%
-> 53322
</code></pre>

<p><dt><a name="ge0"><code>(ge0 'any) -> num | NIL</code></a>
<dd>Returns <code>num</code> when the argument is a number and greater or equal
zero, otherwise <code>NIL</code>. See also <code><a href="#gt0">gt0</a></code>,
<code><a href="#lt0">lt0</a></code>, <code><a href="#=0">=0</a></code> and
<code><a href="#n0">n0</a></code>.

<p><pre><code>
: (ge0 -2)
-> NIL
: (ge0 3)
-> 3
: (ge0 0)
-> 0
</code></pre>


<p><dt><a name="get"><code>(get 'sym1|lst ['sym2|cnt ..]) -> any</code></a>
<dd>Fetches a value <code>any</code> from the properties of a symbol, or from a
list. From the first argument <code>sym1|lst</code>, values are retrieved in
successive steps by either extracting the value (if the next argument is zero)
or a property (if the next argument is a symbol) from a symbol, the <code><a
href="#asoq">asoq</a></code>ed element (if the next argument is a symbol), the
n'th element (if the next argument is a positive number) or the n'th
<code>CDR</code> (if the next argument is a negative number) from a list. See
also <code><a href="#put">put</a></code> and <code><a href="#:">:</a></code>.

<p><pre><code>
: (put 'X 'a 1)
-> 1
: (get 'X 'a)
-> 1
: (put 'Y 'link 'X)
-> X
: (get 'Y 'link)
-> X
: (get 'Y 'link 'a)
-> 1
: (get '((a (b . 1) (c . 2)) (d (e . 3) (f . 4))) 'a 'b)
-> 1
: (get '((a (b . 1) (c . 2)) (d (e . 3) (f . 4))) 'd 'f)
-> 4
: (get '(X Y Z) 2)
-> Y
: (get '(X Y Z) 2 'link 'a)
-> 1
</code></pre>

<p><dt><a name="getl"><code>(getl 'sym1|lst1 ['sym2|cnt ..]) -> lst</code></a>
<dd>Fetches the complete property list <code>lst</code> from a symbol. That
symbol is <code>sym1</code> (if no other arguments are given), or a symbol found
by applying the <code><a href="#get">get</a></code> algorithm to
<code>sym1|lst1</code> and the following arguments. See also <code><a
href="#putl">putl</a></code> and <code><a href="#maps">maps</a></code>.

<p><pre><code>
: (put 'X 'a 1)
-> 1
: (put 'X 'b 2)
-> 2
: (put 'X 'flg T)
-> T
: (getl 'X)
-> (flg (2 . b) (1 . a))
</code></pre>

<p><dt><a name="glue"><code>(glue 'any 'lst) -> sym</code></a>
<dd>Builds a new transient symbol (string) by <code><a
href="#pack">pack</a></code>ing the <code>any</code> argument between the
individual elements of <code>lst</code>. See also <code><a
href="#text">text</a></code>.

<p><pre><code>
: (glue "," '(a b c d))
-> "a,b,c,d"
</code></pre>

<p><dt><a name="goal"><code>(goal '([sym 'any ..] . lst) ['sym 'any ..]) -> lst</code></a>
<dd>Constructs a <a href="#pilog">Pilog</a> query list from the list of clauses
<code>lst</code>. The head of the argument list may consist of a sequence of
symbols and expressions, which are used together with the optional
<code>sym</code> and <code>any</code> arguments to form an initial environment.
See also <code><a href="#prove">prove</a></code>.

<p><pre><code>
: (goal '((likes John @X)))
-> (((1 (0) NIL ((likes John @X)) NIL T)))
: (goal '(@X 'John (likes @X @Y)))
-> (((1 (0) NIL ((likes @X @Y)) NIL ((0 . @X) 1 . John) T)))
</code></pre>

<p><dt><a name="gt0"><code>(gt0 'any) -> num | NIL</code></a>
<dd>Returns <code>num</code> when the argument is a number and greater than
zero, otherwise <code>NIL</code>. See also <code><a href="#ge0">ge0</a></code>,
<code><a href="#lt0">lt0</a></code>, <code><a href="#=0">=0</a></code> and
<code><a href="#n0">n0</a></code>.

<p><pre><code>
: (gt0 -2)
-> NIL
: (gt0 3)
-> 3
</code></pre>


<p><hr>
<h3><a name="h-foo">H</a></h3>

<p><dt><a name="head"><code>(head 'cnt|lst 'lst) -> lst</code></a>
<dd>Returns a new list made of the first <code>cnt</code> elements of
<code>lst</code>. If <code>cnt</code> is negative, it is added to the length of
<code>lst</code>. If the first argument is a <code>lst</code>, <code>head</code>
is a predicate function returning that argument list if it is <code>equal</code>
to the head of the second argument, and <code>NIL</code> otherwise. See also
<code><a href="#tail">tail</a></code>.

<p><pre><code>
: (head 3 '(a b c d e f))
-> (a b c)
: (head 0 '(a b c d e f))
-> NIL
: (head 10 '(a b c d e f))
-> (a b c d e f)
: (head -2 '(a b c d e f))
-> (a b c d)
: (head '(a b c) '(a b c d e f))
-> (a b c)
</code></pre>

<p><dt><a name="heap"><code>(heap 'flg) -> cnt</code></a>
<dd>Returns the number of <i>free</i> cells currently available (if
<code>flg</code> is <code>NIL</code>), or the <i>total</i> number of cells in
the system (if <code>flg</code> is non-<code>NIL</code>).

<p><pre><code>
: (heap)
-> 126999
: (heap T)
-> 262144
</code></pre>

<p><dt><a name="hear"><code>(hear 'num|sym) -> any</code></a>
<dd>Uses the file descriptor <code>num</code>, or opens the file
<code>sym</code>, as an asynchronous command input channel. Any executable list
received via this channel will be executed in the background. As this mechanism
is also used for inter-family communication (see <code><a
href="#tell">tell</a></code>), <code>hear</code> is usually only called
explicitly by a top level parent process.

<p><pre><code>
: (hear "fifo/cmd")
-> "fifo/cmd"
</code></pre>

<p><dt><a name="host"><code>(host 'any) -> sym</code></a>
<dd>Returns the hostname corresponding to the given IP address. See also
<code><a href="#*Adr">*Adr</a></code>.

<p><pre><code>
: (host "217.160.106.89")
-> "software-lab.biz"
</code></pre>


<p><hr>
<h3><a name="i-foo">I</a></h3>

<p><dt><a name="id"><code>(id 'num 'num) -> sym<br>
(id 'sym [NIL]) -> num<br>
(id 'sym T) -> (num . num)</code></a>
<dd>Converts two numbers to an external symbol, or an external symbol to a
number or a pair of numbers.

<p><pre><code>
: (id 1 2)
-> {1-2}
: (id '{1-2})
-> 2
: (id '{1-2} T)
-> (1 . 2)
</code></pre>

<p><dt><a name="idx"><code>(idx 'var 'any 'flg) -> lst<br>
(idx 'var 'any) -> lst<br>
(idx 'var) -> lst</code></a>
<dd>Maintains an index tree in <code>var</code>, and checks for the existence of
<code>any</code>. If <code>any</code> is contained in <code>var</code>, the
corresponding subtree is returned, otherwise <code>NIL</code>. In the first
form, <code>any</code> is destructively inserted into the tree if
<code>flg</code> is non-<code>NIL</code>, or deleted from the tree if
<code>flg</code> is <code>NIL</code>. The second form only checks for existence,
but does not change the index tree. In the third form (when called with a single
<code>var</code> argument) the contents of the tree are returned as a sorted
list. If all elements are inserted in sorted order, the tree degenerates into a
linear list. See also <code><a href="#lup">lup</a></code>, <code><a
href="#sort">sort</a></code> and <code><a href="#member">member</a></code>.

<p><pre><code>
: (idx 'X 'd T)                              # Insert data
-> NIL
: (idx 'X 2 T)
-> NIL
: (idx 'X '(a b c) T)
-> NIL
: (idx 'X 17 T)
-> NIL
: (idx 'X 'A T)
-> NIL
: (idx 'X 'd T)
-> (d (2 NIL 17 NIL A) (a b c))              # 'd' already existed
: (idx 'X T T)
-> NIL
: X                                          # View the index tree
-> (d (2 NIL 17 NIL A) (a b c) NIL T)
: (idx 'X 'A)                                # Check for 'A'
-> (A)
: (idx 'X 'B)                                # Check for 'B'
-> NIL
: (idx 'X)
-> (2 17 A d (a b c) T)                      # Get list
: (idx 'X 17 NIL)                            # Delete '17'
-> (17 NIL A)
: X
-> (d (2 NIL A) (a b c) NIL T)               # View it again
: (idx 'X)
-> (2 A d (a b c) T)                         # '17' is deleted
</code></pre>

<p><dt><a name="if"><code>(if 'any1 'any2 . prg) -> any</code></a>
<dd>Conditional execution: If the condition <code>any1</code> evaluates to
non-<code>NIL</code>, <code>any2</code> is evaluated and returned. Otherwise,
<code>prg</code> is executed and the result returned. See also <code><a
href="#cond">cond</a></code>, <code><a href="#when">when</a></code> and <code><a
href="#if2">if2</a></code>.

<p><pre><code>
: (if (> 4 3) (println 'Ok) (println 'Bad))
Ok
-> Ok
: (if (> 3 4) (println 'Ok) (println 'Bad))
Bad
-> Bad
</code></pre>

<p><dt><a name="if2"><code>(if2 'any1 'any2 'any3 'any4 'any5 . prg) -> any</code></a>
<dd>Four-way conditional execution for two conditions: If both conditions
<code>any1</code> and <code>any2</code> evaluate to non-<code>NIL</code>,
<code>any3</code> is evaluated and returned. Otherwise, <code>any4</code> or
<code>any5</code> is evaluated and returned if <code>any1</code> or
<code>any2</code> evaluate to non-<code>NIL</code>, respectively. If none of the
conditions evaluate to non-<code>NIL</code>, <code>prg</code> is executed and
the result returned. See also <code><a href="#if">if</a></code> and <code><a
href="#cond">cond</a></code>.

<p><pre><code>
: (if2 T T 'both 'first 'second 'none)
-> both
: (if2 T NIL 'both 'first 'second 'none)
-> first
: (if2 NIL T 'both 'first 'second 'none)
-> second
: (if2 NIL NIL 'both 'first 'second 'none)
-> none
</code></pre>

<p><dt><a name="ifn"><code>(ifn 'any1 'any2 . prg) -> any</code></a>
<dd>Conditional execution ("If not"): If the condition <code>any1</code>
evaluates to <code>NIL</code>, <code>any2</code> is evaluated and returned.
Otherwise, <code>prg</code> is executed and the result returned.

<p><pre><code>
: (ifn (= 3 4) (println 'Ok) (println 'Bad))
Ok
-> Ok
</code></pre>

<p><dt><a name="in"><code>(in 'any . prg) -> any</code></a>
<dd>Opens <code>any</code> as input channel during the execution of
<code>prg</code>. The current input channel will be saved and restored
appropriately. If the argument is <code>NIL</code>, standard input is used. If
the argument is a symbol, it is used as a file name (opened for reading
<i>and</i> writing if the first character is "<code>+</code>"). If it is a
number, it is used as the descriptor of an open file. Otherwise (if it is a
list), it is taken as a command with arguments, and a pipe is opened for input.
See also <code><a href="#call">call</a></code>, <code><a
href="#load">load</a></code>, <code><a href="#out">out</a></code>, <code><a
href="#pipe">pipe</a></code> and <code><a href="#ctl">ctl</a></code>.

<p><pre><code>
: (in "a" (list (read) (read) (read)))    # Read three items from file "a"
-> (123 (a b c) def)
</code></pre>

<p><dt><a name="inc"><code>(inc 'num) -> num<br>
(inc 'var ['num]) -> num</code></a>
<dd>The first form returns the value of <code>num</code> incremented by 1. The
second form increments the <code>VAL</code> of <code>var</code> by 1, or by
<code>num</code>. <code>(inc 'num)</code> is equivalent to <code>(+ 'num
1)</code> and <code>(inc 'var)</code> is equivalent to <code>(set 'var (+ var
1))</code>.

<p><pre><code>
: (inc 7)
-> 8
: (inc -1)
-> 0
: (zero N)
-> 0
: (inc 'N)
-> 1
: (inc 'N 7)
-> 8
: N
-> 8

: (setq L (1 2 3 4))
-> (1 2 3 4)
: (inc (cdr L))
-> 3
: L
-> (1 3 3 4)
</code></pre>

<p><dt><a name="index"><code>(index 'any 'lst) -> cnt | NIL</code></a>
<dd>Returns the <code>cnt</code> position of <code>any</code> in
<code>lst</code>, or <code>NIL</code> if it is not found. See also <code><a
href="#offset">offset</a></code>.

<p><pre><code>
: (index 'c '(a b c d e f))
-> 3
: (index '(5 6) '((1 2) (3 4) (5 6) (7 8)))
-> 3
</code></pre>

<p><dt><a name="info"><code>(info 'any) -> (cnt|T dat . tim)</code></a>
<dd>Returns information about a file with the name <code>any</code>: The current
size <code>cnt</code> in bytes, and the modification date and time (UTC). For
directories, <code>T</code> is returned instead of the a size. See also <code><a
href="#dir">dir</a></code>, <code><a href="#date">date</a></code>, <code><a
href="#time">time</a></code> and <code><a href="#lines">lines</a></code>.

<p><pre><code>
$ ls -l x.l
-rw-r--r--   1 abu      users         208 Jun 17 08:58 x.l
$ ./p dbg.l
: (info "x.l")
-> (208 730594 . 32315)
: (stamp 730594 32315)
-> "2000-06-17 08:58:35"
</code></pre>

<p><dt><a name="intern"><code>(intern 'sym) -> sym</code></a>
<dd>Creates or finds an internal symbol. If a symbol with the name
<code>sym</code> is already intern, it is returned. Otherwise, <code>sym</code>
is interned and returned. See also <code><a href="#zap">zap</a></code>, <code><a
href="#extern">extern</a></code> and <code><a href="#====">====</a></code>.

<p><pre><code>
: (intern "abc")
-> abc
: (intern 'car)
-> car
: ((intern (pack "c" "a" "r")) (1 2 3))
-> 1
</code></pre>

<p><dt><a name="isa"><code>(isa 'cls|typ 'any) -> flg</code></a>
<dd>Returns <code>T</code> when <code>any</code> is an object that inherits from
<code>cls</code> or <code>type</code>. See also <code><a
href="#type">type</a></code>.

<p><pre><code>
: (isa '+Address Obj)
-> T
: (isa '(+Male +Person) Obj)
-> NIL
</code></pre>


<p><hr>
<h3><a name="j-foo">J</a></h3>

<p><dt><a name="job"><code>(job 'lst . prg) -> any</code></a>
<dd>Executes a job within its own environment (as specified by symbol-value
pairs in <code>lst</code>). The current values of all symbols are saved, the
symbols are bound to the values in <code>lst</code>, <code>prg</code> is
executed, then the (possibly modified) symbol values are (destructively) stored
in the environment list, and the symbols are restored to their original values.
The return value is the result of <code>prg</code>. Typically used in a <code><a
href="#*Run">*Run</a></code> task. See also <code><a href="#env">env</a></code>,
<code><a href="#bind">bind</a></code>, <code><a href="#let">let</a></code>,
<code><a href="#use">use</a></code> and <code><a href="#state">state</a></code>.

<p><pre><code>
: (de tst ()
   (job '((A . 0) (B . 0))
      (println (inc 'A) (inc 'B 2)) ) )
-> tst
: (tst)
1 2
-> 2
: (tst)
2 4
-> 4
: (tst)
3 6
-> 6
: (pp 'tst)
(de tst NIL
   (job '((A . 3) (B . 6))
      (println (inc 'A) (inc 'B 2)) ) )
-> tst
</code></pre>

<p><dt><a name="journal"><code>(journal) -> T</code></a>
<dd>Reads journal data from the current input channel, and writes all changes to
the database. See also <code><a href="#pool">pool</a></code>.

<p><pre><code>
: (in "db.log" (journal))
-> T
</code></pre>


<p><hr>
<h3><a name="k-foo">K</a></h3>

<p><dt><a name="key"><code>(key ['cnt]) -> sym</code></a>
<dd>Returns the next character from standard input as a single-character
transient symbol. The console is set to raw mode. While waiting for a key press,
a <code>select</code> system call is executed for all file descriptors and
timers in the <code>VAL</code> of the global variable <code><a
href="#*Run">*Run</a></code>. If <code>cnt</code> is non-<code>NIL</code>, that
amount of milliseconds is waited maximally, and <code>NIL</code> is returned
upon timeout. See also <code><a href="#raw">raw</a></code> and <code><a
href="#wait">wait</a></code>.

<p><pre><code>
: (key)                    # Wait for a key
-> "a"                     # 'a' pressed
</code></pre>

<p><dt><a name="kill"><code>(kill 'pid ['cnt]) -> flg</code></a>
<dd>Sends a signal with the signal number <code>cnt</code> (or SIGTERM if
<code>cnt</code> is not given) to the process with the ID <code>pid</code>.
Returns <code>T</code> if successful.

<p><pre><code>
: (kill *Pid 20)                                # Stop current process

[2]+  Stopped               bin/picolisp        # Unix shell
$ fg                                            # Job control: Foreground
bin/picolisp
-> T                                            # 'kill' was successful
</code></pre>


<p><hr>
<h3><a name="l-foo">L</a></h3>

<p><dt><a name="last"><code>(last 'lst) -> any</code></a>
<dd>Returns the last element of <code>lst</code>. See also <code><a
href="#fin">fin</a></code> and <code><a href="#tail">tail</a></code>.

<p><pre><code>
: (last (1 2 3 4))
-> 4
: (last '((a b) c (d e f)))
-> (d e f)
</code></pre>

<p><dt><a name="length"><code>(length 'any) -> cnt | T</code></a>
<dd>Returns the "length" of <code>any</code>. For numbers this is the number of
digits in the value (plus 1 for negative values), for symbols it is the number
of characters in the name, and for lists it is the number of elements (or
<code>T</code> for circular lists). See also <code><a
href="#size">size</a></code>.

<p><pre><code>
: (length "abc")
-> 3
: (length "√§bc")
-> 3
: (length 123)
-> 3
: (length (1 (2) 3))
-> 3
: (length (1 2 3 .))
-> T
</code></pre>

<p><dt><a name="let"><code>(let sym 'any . prg) -> any<br>
(let (sym 'any ..) . prg) -> any</code></a>
<dd>Defines local variables. The value of the symbol <code>sym</code> - or the
values of the symbols <code>sym</code> in the list of the second form - are
saved and the symbols are bound to the evaluated <code>any</code> arguments.
<code>prg</code> is executed, then the symbols are restored to their original
values. The result of <code>prg</code> is returned. It is an error condition to
pass <code>NIL</code> as a <code>sym</code> argument. See also <code><a
href="#letQ">let?</a></code>, <code><a href="#bind">bind</a></code>, <code><a
href="#job">job</a></code> and <code><a href="#use">use</a></code>.

<p><pre><code>
: (setq  X 123  Y 456)
-> 456
: (let X "Hello" (println X))
"Hello"
-> "Hello"
: (let (X "Hello" Y "world") (prinl X " " Y))
Hello world
-> "world"
: X
-> 123
: Y
-> 456
</code></pre>

<p><dt><a name="letQ"><code>(let? sym 'any . prg) -> any</code></a>
<dd>Conditional local variable binding and execution: If <code>any</code>
evalutes to <code>NIL</code>, <code>NIL</code> is returned. Otherwise, the value
of the symbol <code>sym</code> is saved and <code>sym</code> is bound to the
evaluated <code>any</code> argument. <code>prg</code> is executed, then
<code>sym</code> is restored to its original value. The result of
<code>prg</code> is returned. It is an error condition to pass <code>NIL</code>
as the <code>sym</code> argument. <code>(let? sym 'any ..)</code> is equivalent
to <code>(when 'any (let sym @ ..))</code>. See also <code><a
href="#let">let</a></code>, <code><a href="#bind">bind</a></code>, <code><a
href="#job">job</a></code> and <code><a href="#use">use</a></code>.

<p><pre><code>
: (setq Lst (1 NIL 2 NIL 3))
-> (1 NIL 2 NIL 3)
: (let? A (pop 'Lst) (println 'A A))
A 1
-> 1
: (let? A (pop 'Lst) (println 'A A))
-> NIL
</code></pre>

<p><dt><a name="lieu"><code>(lieu 'any) -> sym | NIL</code></a>
<dd>Returns the argument <code>any</code> when it is an external symbol and
currently manifest in heap space, otherwise <code>NIL</code>. See also <code><a
href="#extQ">ext?</a></code>.

<p><pre><code>
: (lieu *DB)
-> {1}
</code></pre>

<p><dt><a name="line"><code>(line 'flg ['cnt ..]) -> lst|sym</code></a>
<dd>Reads a line of characters from the current input channel. End of line is
recognized as linefeed (hex "0A"), carriage return (hex "0D"), or the
combination of both. (Note that a single carriage return may not work on network
connections, because the character look-ahead to distinguish from
return+linefeed can block the connection.) If <code>flg</code> is
<code>NIL</code>, a list of single-character transient symbols is returned. When
<code>cnt</code> arguments are given, subsequent characters of the input line
are grouped into sublists, to allow parsing of fixed field length records. If
<code>flg</code> is non-<code>NIL</code>, strings are returned instead of
single-character lists. <code>NIL</code> is returned upon end of file. See also
<code><a href="#char">char</a></code>, <code><a href="#till">till</a></code> and
<code><a href="#eof">eof</a></code>.

<p><pre><code>
: (line)
abcdefghijkl
-> ("a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l")
: (line T)
abcdefghijkl
-> "abcdefghijkl"
: (line NIL 1 2 3)
abcdefghijkl
-> (("a") ("b" "c") ("d" "e" "f") "g" "h" "i" "j" "k" "l")
: (line T 1 2 3)
abcdefghijkl
-> ("a" "bc" "def" "g" "h" "i" "j" "k" "l")
</code></pre>

<p><dt><a name="lines"><code>(lines 'any ..) -> cnt</code></a>
<dd>Returns the sum of the number of lines in the files with the names
<code>any</code>. See also <code><a href="#info">info</a></code>.

<p><pre><code>
: (lines "x.l")
-> 11
</code></pre>

<p><dt><a name="link"><code>(link 'any ..) -> any</code></a>
<dd>Links one or several new elements <code>any</code> to the end of the list in
the current <code><a href="#make">make</a></code> environment. This operation is
efficient also for long lists, because a pointer to the last element of the list
is maintained. <code>link</code> returns the last linked argument. See also
<code><a href="#chain">chain</a></code> and <code><a
href="#made">made</a></code>.

<p><pre><code>
: (make
   (println (link 1))
   (println (link 2 3)) )
1
3
-> (1 2 3)
</code></pre>

<p><dt><a name="list"><code>(list 'any ..) -> lst</code></a>
<dd>Returns a list of all <code>any</code> arguments.

<p><pre><code>
: (list 1 2 3 4)
-> (1 2 3 4)
: (list 'a (2 3) "Ok")
-> (a (2 3) "Ok")
</code></pre>

<p><dt><a name="listQ"><code>(lst? 'any) -> flg</code></a>
<dd>Returns <code>T</code> when the argument <code>any</code> is a (possibly
empty) list (<code>NIL</code> or a cons pair cell). See also <code><a
href="#pair">pair</a></code>.

<p><pre><code>
: (lst? NIL)
-> T
: (lst? (1 . 2))
-> T
: (lst? (1 2 3))
-> T
</code></pre>

<p><dt><a name="listen"><code>(listen 'cnt1 ['cnt2]) -> cnt | NIL</code></a>
<dd>Listens at a socket descriptor <code>cnt1</code> (as received by <code><a
href="#port">port</a></code>) for an incoming connection, and returns the new
socket descriptor <code>cnt</code>. While waiting for a connection, a
<code>select</code> system call is executed for all file descriptors and timers
in the <code>VAL</code> of the global variable <code><a
href="#*Run">*Run</a></code>. If <code>cnt2</code> is non-<code>NIL</code>, that
amount of milliseconds is waited maximally, and <code>NIL</code> is returned
upon timeout. The global variable <code>*Adr</code> is set to the IP address of
the client. See also <code><a href="#accept">accept</a></code>, <code><a
href="#connect">connect</a></code>, <code><a href="#nagle">nagle</a></code> and
<code><a href="#*Adr">*Adr</a></code>.

<p><pre><code>
: (setq *Socket
   (listen (port 6789) 60000) )  # Listen at port 6789 for max 60 seconds
-> 4
: *Adr
-> "127.0.0.1"
</code></pre>

<p><dt><a name="lit"><code>(lit 'any) -> any</code></a>
<dd>Returns the literal (i.e. quoted) value of <code>any</code>, by
<code>cons</code>ing it with the <code><a href="#quote">quote</a></code>
function if necessary.

<p><pre><code>
: (lit T)
-> T
: (lit 1)
-> 1
: (lit '(1))
-> (1)
: (lit '(a))
-> '(a)
</code></pre>

<p><dt><a name="load"><code>(load 'any ..) -> any</code></a>
<dd>Loads all <code>any</code> arguments. Normally, the name of each argument is
taken as a file to be executed in a read-eval loop. The argument semantics are
identical to that of <code><a href="#in">in</a></code>, with the exception that
if an argument is a symbol and its first character is a hyphen '-', then that
argument is parsed as a function call (without the surrounding parentheses).
When <code>any</code> is <code>T</code>, all remaining command line arguments
are loaded recursively. When <code>any</code> is <code>NIL</code>, standard
input is read, a prompt is issued before each read operation, the results are
printed to standard output (read-eval-print loop), and <code>load</code>
terminates when an empty line is entered. In any case, <code>load</code>
terminates upon end of file, or when <code>NIL</code> is read. The hash table
for transient symbols is cleared before and after the load, so that all
transient symbols in the file have a local scope. Returns the value of the last
evaluated expression. See also <code><a href="#call">call</a></code>, <code><a
href="#in">in</a></code>, <code><a href="#out">out</a></code> and <code><a
href="#str">str</a></code>.

<p><pre><code>
: (load "lib.l" "-* 1 2 3")
-> 6
</code></pre>

<p><dt><a name="lock"><code>(lock ['sym]) -> cnt | NIL</code></a>
<dd>Write-locks an external symbol <code>sym</code> (file record locking), or
the whole database root file if <code>sym</code> is <code>NIL</code>. Returns
<code>NIL</code> if successful, or the ID of the process currently holding the
lock. When <code>sym</code> is non-<code>NIL</code>, the lock is released at the
next top level call to <code><a href="#commit">commit</a></code> or <code><a
href="#rollback">rollback</a></code>, otherwise only when another database is
opened with <code><a href="#pool">pool</a></code>, or when the process
terminates. See also <code><a href="#*Solo">*Solo</a></code>.

<p><pre><code>
: (lock '{1})        # Lock single object
-> NIL
: (lock)             # Lock whole database
-> NIL
</code></pre>

<p><dt><a name="lookup"><code>(-&gt sym [num]) -> any</code></a>
<dd>Searches for the current value of the pattern variable <code>sym</code> at
top level (or level <code>num</code>) in the current <a href="#pilog">Pilog</a>
environment. See also <code><a href="#prove">prove</a></code> and <code><a
href="#unify">unify</a></code>.

<p><pre><code>
: (? (append (1 2 3) (4 5 6) @X) (@ println 'X '= (-> @X)))
X = (1 2 3 4 5 6)
 @X=(1 2 3 4 5 6)
-> NIL
</code></pre>

<p><dt><a name="loop"><code>(loop ['any | (NIL 'any . prg) | (T 'any . prg) ..]) -> any</code></a>
<dd>Endless loop with multiple conditional exits: The body is executed an
unlimited number of times. If a clause has <code>NIL</code> or <code>T</code> as
its <code>CAR</code>, the clause's second element is evaluated as a condition
and - if the result is <code>NIL</code> or non-<code>NIL</code>, respectively -
the <code>prg</code> is executed and the result returned. See also <code><a
href="#do">do</a></code> and <code><a href="#for">for</a></code>.

<p><pre><code>
: (let N 3
   (loop
      (prinl N)
      (T (=0 (dec 'N)) 'done) ) )
3
2
1
-> done
</code></pre>

<p><dt><a name="lowQ"><code>(low? 'any) -> sym | NIL</code></a>
<dd>Returns <code>any</code> when the argument is a string (symbol) that starts
with a lowercase character. See also <code><a href="#lowc">lowc</a></code>.

<p><pre><code>
: (low? "a")
-> "a"
: (low? "A")
-> NIL
: (low? 123)
-> NIL
: (low? ".")
-> NIL
</code></pre>

<p><dt><a name="lowc"><code>(lowc 'any) -> any</code></a>
<dd>Lower case conversion: If <code>any</code> is not a symbol, it is returned
as it is. Otherwise, a new transient symbol with all characters of
<code>any</code>, converted to lower case, is returned. See also <code><a
href="#uppc">uppc</a></code>, <code><a href="#fold">fold</a></code> and <code><a
href="#lowQ">low?</a></code>.

<p><pre><code>
: (lowc 123)
-> 123
: (lowc "ABC")
-> "abc"
</code></pre>

<p><dt><a name="lt0"><code>(lt0 'any) -> num | NIL</code></a>
<dd>Returns <code>num</code> when the argument is a number and less than zero,
otherwise <code>NIL</code>. See also <code><a href="#ge0">ge0</a></code>,
<code><a href="#gt0">gt0</a></code>, <code><a href="#=0">=0</a></code> and
<code><a href="#n0">n0</a></code>.

<p><pre><code>
: (lt0 -2)
-> -2
: (lt0 3)
-> NIL
</code></pre>

<p><dt><a name="lup"><code>(lup 'lst 'any) -> lst<br>
(lup 'lst 'any 'any2) -> lst</code></a>
<dd>Looks up <code>any</code> in the CAR-elements of cells stored in the index
tree <code>lst</code>, as built up by <code><a href="#idx">idx</a></code>. In
the first form, the first found cell is returned, in the second form a list of
all cells whose CAR is in the range <code>any</code> .. <code>any2</code>. See
also <code><a href="#assoc">assoc</a></code>.

<p><pre><code>
: (idx 'A 'a T)
-> NIL
: (idx 'A (1 . b) T)
-> NIL
: (idx 'A 123 T)
-> NIL
: (idx 'A (1 . a) T)
-> NIL
: (idx 'A (1 . c) T)
-> NIL
: (idx 'A (2 . d) T)
-> NIL
: (idx 'A)
-> (123 a (1 . a) (1 . b) (1 . c) (2 . d))
: (lup A 1)
-> (1 . b)
: (lup A 2)
-> (2 . d)
: (lup A 1 1)
-> ((1 . a) (1 . b) (1 . c))
: (lup A 1 2)
-> ((1 . a) (1 . b) (1 . c) (2 . d))
</code></pre>


<p><hr>
<h3><a name="m-foo">M</a></h3>

<p><dt><a name="made"><code>(made ['lst1 ['lst2]]) -> lst</code></a>
<dd>Initializes a new list value for the current <code><a
href="#make">make</a></code> environment. All list elements already produced
with <code><a href="#chain">chain</a></code> and <code><a
href="#link">link</a></code> are discarded, and <code>lst1</code> is used
instead. Optionally, <code>lst2</code> can be specified as the new linkage cell,
otherwise the last cell of <code>lst1</code> is used. When called without
arguments, <code>made</code> does not modify the environment. In any case, the
current list is returned.

<p><pre><code>
: (make
   (link 'a 'b 'c)         # Link three items
   (println (made))        # Print current list (a b c)
   (made (1 2 3))          # Discard it, start new with (1 2 3)
   (link 4) )              # Link 4
(a b c)
-> (1 2 3 4)
</code></pre>

<p><dt><a name="make"><code>(make .. [(made 'lst ..)] .. [(link 'any ..)] ..) -> any</code></a>
<dd>Initializes and executes a list-building process with the <code><a
href="#made">made</a></code>, <code><a href="#chain">chain</a></code> and
<code><a href="#link">link</a></code> functions, and returns the result list.
For efficiency, pointers to the head and the tail of the list are maintained
internally.

<p><pre><code>
: (make (link 1) (link 2 3) (link 4))
-> (1 2 3 4)
: (make (made (1 2 3)) (link 4))
-> (1 2 3 4)
</code></pre>

<p><dt><a name="map"><code>(map 'fun 'lst ..) -> lst</code></a>
<dd>Applies <code>fun</code> to <code>lst</code> and all successive
<code>CDR</code>'s. When additional <code>lst</code> arguments are given, they
are passed to <code>fun</code> in the same way. Returns the result of the last
application.

<p><pre><code>
: (map println (1 2 3 4) '(A B C))
(1 2 3 4) (A B C)
(2 3 4) (B C)
(3 4) (C)
(4) NIL
-> NIL
</code></pre>

<p><dt><a name="mapc"><code>(mapc 'fun 'lst ..) -> any</code></a>
<dd>Applies <code>fun</code> to each element of <code>lst</code>. When
additional <code>lst</code> arguments are given, their elements are also passed
to <code>fun</code>. Returns the result of the last application.

<p><pre><code>
: (mapc println (1 2 3 4) '(A B C))
1 A
2 B
3 C
4 NIL
-> NIL
</code></pre>

<p><dt><a name="mapcan"><code>(mapcan 'fun 'lst ..) -> lst</code></a>
<dd>Applies <code>fun</code> to each element of <code>lst</code>. When
additional <code>lst</code> arguments are given, their elements are also passed
to <code>fun</code>. Returns a (destructively) concatenated list of all results.

<p><pre><code>
: (mapcan reverse '((a b c) (d e f) (g h i)))
-> (c b a f e d i h g)
</code></pre>

<p><dt><a name="mapcar"><code>(mapcar 'fun 'lst ..) -> lst</code></a>
<dd>Applies <code>fun</code> to each element of <code>lst</code>. When
additional <code>lst</code> arguments are given, their elements are also passed
to <code>fun</code>. Returns a list of all results.

<p><pre><code>
: (mapcar + (1 2 3) (4 5 6))
-> (5 7 9)
: (mapcar '((X Y) (+ X (* Y Y))) (1 2 3 4) (5 6 7 8))
-> (26 38 52 68)
</code></pre>

<p><dt><a name="mapcon"><code>(mapcon 'fun 'lst ..) -> lst</code></a>
<dd>Applies <code>fun</code> to <code>lst</code> and all successive
<code>CDR</code>'s. When additional <code>lst</code> arguments are given, they
are passed to <code>fun</code> in the same way. Returns a (destructively)
concatenated list of all results.

<p><pre><code>
: (mapcon copy '(1 2 3 4 5))
-> (1 2 3 4 5 2 3 4 5 3 4 5 4 5 5)
</code></pre>

<p><dt><a name="maplist"><code>(maplist 'fun 'lst ..) -> lst</code></a>
<dd>Applies <code>fun</code> to <code>lst</code> and all successive
<code>CDR</code>'s. When additional <code>lst</code> arguments are given, they
are passed to <code>fun</code> in the same way. Returns a list of all results.

<p><pre><code>
: (maplist cons (1 2 3) '(A B C))
-> (((1 2 3) A B C) ((2 3) B C) ((3) C))
</code></pre>

<p><dt><a name="maps"><code>(maps 'fun 'sym ['lst ..]) -> any</code></a>
<dd>Applies <code>fun</code> to all properties of <code>sym</code>. When
additional <code>lst</code> arguments are given, their elements are also passed
to <code>fun</code>. Returns the result of the last application. See also
<code><a href="#putl">putl</a></code> and <code><a href="#getl">getl</a></code>.

<p><pre><code>
: (put 'X 'a 1)
-> 1
: (put 'X 'b 2)
-> 2
: (put 'X 'flg T)
-> T
: (getl 'X)
-> (flg (2 . b) (1 . a))
: (maps println 'X '(A B))
flg A
(2 . b) B
(1 . a) NIL
-> NIL
</code></pre>

<p><dt><a name="mark"><code>(mark 'sym|0 [NIL | T | 0]) -> flg</code></a>
<dd>Tests, sets or resets a mark for <code>sym</code> in the database (for a
second argument of <code>NIL</code>, <code>T</code> or <code>0</code>,
respectively), and returns the old value. The marks are local to the current
process (not stored in the database), and vanish when the process terminates. If
the first argument is zero, all marks are cleared.

<p><pre><code>
: (pool "db")
-> T
: (mark '{1} T)      # Mark
-> NIL
: (mark '{1})        # Test
-> T                 # -> marked
: (mark '{1} 0)      # Unmark
-> T
: (mark '{1})        # Test
-> NIL               # -> unmarked
</code></pre>

<p><dt><a name="match"><code>(match 'lst1 'lst2) -> flg</code></a>
<dd>Takes <code>lst1</code> as a pattern to be matched against
<code>lst2</code>, and returns <code>T</code> when successful. Atoms must be
equal, and sublists must match recursively. Symbols in the pattern list with
names starting with an at-mark "<code>@</code>" (see <code><a
href="#patQ">pat?</a></code>) are taken as wildcards. They can match zero, one
or more elements, and are bound to the corresponding data. See also <code><a
href="#chop">chop</a></code>, <code><a href="#split">split</a></code> and
<code><a href="#fill">fill</a></code>.

<p><pre><code>
: (match '(@A is @B) '(This is a test))
-> T
: @A
-> (This)
: @B
-> (a test)
: (match '(@X (d @Y) @Z) '((a b c) (d (e f) g) h i))
-> T
: @X
-> ((a b c))
: @Y
-> ((e f) g)
: @Z
-> (h i)
</code></pre>

<p><dt><a name="max"><code>(max 'any ..) -> any</code></a>
<dd>Returns the largest of all <code>any</code> arguments. See also <a
href="#cmp">Comparing</a>.

<p><pre><code>
: (max 2 'a 'z 9)
-> z
: (max (5) (2 3) 'X)
-> (5)
</code></pre>

<p><dt><a name="maxi"><code>(maxi 'fun 'lst ..) -> any</code></a>
<dd>Applies <code>fun</code> to each element of <code>lst</code>. When
additional <code>lst</code> arguments are given, their elements are also passed
to <code>fun</code>. Returns that element from <code>lst</code> for that
<code>fun</code> returned a maximal value. See also <code><a
href="#mini">mini</a></code>.

<p><pre><code>
: (setq A 1  B 2  C 3)
-> 3
: (maxi val '(A B C))
-> C
: (maxi                          # Symbol with largest list value
   '((X)
      (and (pair (val X)) (size @)) )
   (what) )
-> *History
</code></pre>

<p><dt><a name="member"><code>(member 'any 'lst) -> any</code></a>
<dd>Returns the tail of <code>lst</code> that starts with <code>any</code> when
<code>any</code> is a member of <code>lst</code>, otherwise <code>NIL</code>.
See also <code><a href="#memq">memq</a></code>, <code><a
href="#assoc">assoc</a></code> and <code><a href="#idx">idx</a></code>.

<p><pre><code>
: (member 3 (1 2 3 4 5 6))
-> (3 4 5 6)
: (member 9 (1 2 3 4 5 6))
-> NIL
: (member '(d e f) '((a b c) (d e f) (g h i)))
-> ((d e f) (g h i))
</code></pre>

<p><dt><a name="memq"><code>(memq 'any 'lst) -> any</code></a>
<dd>Returns the tail of <code>lst</code> that starts with <code>any</code> when
<code>any</code> is a member of <code>lst</code>, otherwise <code>NIL</code>.
<code><a href="#==">==</a></code> is used for comparison (pointer equality). See
also <code><a href="#member">member</a></code>, <code><a
href="#mmeq">mmeq</a></code>, <code><a href="#asoq">asoq</a></code> and <code><a
href="#delq">delq</a></code>.

<p><pre><code>
: (memq 'c '(a b c d e f))
-> (c d e f)
: (memq 3 (1 2 3 4 5 6))
-> NIL
</code></pre>

<p><dt><a name="meta"><code>(meta 'obj|typ 'sym ['sym2|cnt ..]) -> any</code></a>
<dd>Fetches a property value <code>any</code>, by searching the property lists
of the classes and superclasses of <code>obj</code>, or the classes in
<code>typ</code>, for the property key <code>sym</code>, and by applying the
<code><a href="#get">get</a></code> algorithm to the following optional
arguments.

<p><pre><code>
: (setq A '(B))            # Be 'A' an object of class 'B'
-> (B)
: (put 'B 'a 123)
-> 123
: (meta 'A 'a)             # Fetch 'a' from 'B'
-> 123
</code></pre>

<p><dt><a name="meth"><code>(meth 'obj ..) -> any</code></a>
<dd>This function is usually not called directly, but is used by <code>dm</code>
as a template to initialize the <code>VAL</code> of message symbols. It searches
for itself in the methods of <code>obj</code> and its classes and superclasses,
and executes that method. An error <code>"Bad message"</code> is issued if the
search is unsuccessful.

<p><pre><code>
: meth
-> 67283504    # Value of 'meth'
: stop>
-> 67283504    # Value of any message
</code></pre>

<p><dt><a name="method"><code>(method 'msg 'obj) -> fun</code></a>
<dd>Returns the function body of the method that would be executed upon sending
the message <code>msg</code> to the object <code>obj</code>. If the message
cannot be located in <code>obj</code>, its classes and superclasses,
<code>NIL</code> is returned. See also <code><a href="#send">send</a></code> and
<code><a href="#try">try</a></code>.

<p><pre><code>
: (method 'mis> '+Number)
-> ((Val Obj) (and Val (not (num? Val)) "Numeric input expected"))
</code></pre>

<p><dt><a name="min"><code>(min 'any ..) -> any</code></a>
<dd>Returns the smallest of all <code>any</code> arguments. See also <a
href="#cmp">Comparing</a>.

<p><pre><code>
: (min 2 'a 'z 9)
-> 2
: (min (5) (2 3) 'X)
-> X
</code></pre>

<p><dt><a name="mini"><code>(mini 'fun 'lst ..) -> any</code></a>
<dd>Applies <code>fun</code> to each element of <code>lst</code>. When
additional <code>lst</code> arguments are given, their elements are also passed
to <code>fun</code>. Returns that element from <code>lst</code> for that
<code>fun</code> returned a minimal value. See also <code><a
href="#maxi">maxi</a></code>.

<p><pre><code>
: (setq A 1  B 2  C 3)
-> 3
: (mini val '(A B C))
-> A
</code></pre>

<p><dt><a name="mix"><code>(mix 'lst cnt|'any ..) -> lst</code></a>
<dd>Builds a list from the elements of the argument <code>lst</code>, as
specified by the following <code>cnt|'any</code> arguments. If such an argument
is a number, the <code>cnt</code>'th element from <code>lst</code> is taken,
otherwise that arguments is evaluated and the result is used.

<p><pre><code>
: (mix '(a b c d) 3 4 1 2)
-> (c d a b)
: (mix '(a b c d) 1 'A 4 'D)
-> (a A d D)
</code></pre>

<p><dt><a name="mmeq"><code>(mmeq 'lst 'lst) -> any</code></a>
<dd>Returns the tail of the second argument <code>lst</code> that starts with a
member of the first argument <code>lst</code>, otherwise <code>NIL</code>.
<code><a href="#==">==</a></code> is used for comparison (pointer equality). See
also <code><a href="#member">member</a></code>, <code><a
href="#memq">memq</a></code>, <code><a href="#asoq">asoq</a></code> and <code><a
href="#delq">delq</a></code>.

<p><pre><code>
: (mmeq '(a b c) '(d e f))
-> NIL
: (mmeq '(a b c) '(d b x))
-> (b x)
</code></pre>


<p><hr>
<h3><a name="n-foo">N</a></h3>

<p><dt><a name="n=="><code>(n== 'any ..) -> flg</code></a>
<dd>Returns <code>T</code> when not all <code>any</code> arguments are the same
(pointer equality). <code>(n== 'any ..)</code> is equivalent to <code>(not (==
'any ..))</code>. See also <code><a href="#==">==</a></code>.

<p><pre><code>
: (n== 'a 'a)
-> NIL
: (n== 1 1)
-> T
</code></pre>

<p><dt><a name="n0"><code>(n0 'any) -> flg</code></a>
<dd>Returns <code>T</code> when <code>any</code> is not a number with value
zero. See also <code><a href="#=0">=0</a></code>, <code><a
href="#lt0">lt0</a></code>, <code><a href="#ge0">ge0</a></code> and <code><a
href="#gt0">gt0</a></code>.

<p><pre><code>
: (n0 (- 6 3 2 1))
-> NIL
: (n0 'a)
-> T
</code></pre>

<p><dt><a name="nT"><code>(nT 'any) -> flg</code></a>
<dd>Returns <code>T</code> when <code>any</code> is not the symbol
<code>T</code>. See also <a href="#=T">=T</a>.

<p><pre><code>
: (nT 0)
-> T
: (nT "T")
-> T
: (nT T)
-> NIL
</code></pre>

<p><dt><a name="nagle"><code>(nagle 'cnt 'flg) -> cnt</code></a>
<dd>Disables the "nagle" algorithm for the socket descriptor <code>cnt</code> if
<code>flg</code> is <code>NIL</code>, or enables it if <code>flg</code> is
non-<code>NIL</code>. Returns the socket descriptor. See also <code><a
href="#listen">listen</a></code> and <code><a
href="#connect">connect</a></code>.

<p><pre><code>
: (nagle (connect "localhost" 8080) NIL)  # Disable the nagle algorithm
-> 3
</code></pre>

<p><dt><a name="name"><code>(name 'sym ['sym2]) -> sym</code></a>
<dd>Returns, if <code>sym2</code> is not given, a new transient symbol with the
name of <code>sym</code>. Otherwise <code>sym</code> must be a transient symbol,
and its name is changed to that of <code>sym2</code>. See also <code><a
href="#str">str</a></code>, <code><a href="#sym">sym</a></code>, <code><a
href="#zap">zap</a></code> and <code><a href="#intern">intern</a></code>.

<p><pre><code>
: (name 'abc)
-> "abc"
: (name "abc")
-> "abc"
: (name '{abc})
-> "abc"
: (name (new))
-> NIL
: (de foo (Lst) (car Lst))          # 'foo' calls 'car'
-> foo
: (intern (name (zap 'car) "xxx"))  # Globally change the name of 'car'
-> xxx
: (xxx (1 2 3))
-> 1
: (pp 'foo)
(de foo (Lst)
   (xxx Lst) )                      # Name changed
-> foo
: (foo (1 2 3))                     # 'foo' still works
-> 1
: (car (1 2 3))                     # Reader returns a new 'car' symbol
!? (car (1 2 3))
car -- Undefined
?
</code></pre>

<p><dt><a name="nand"><code>(nand 'any ..) -> flg</code></a>
<dd>Logical NAND. The expressions <code>any</code> are evaluated from left to
right. If <code>NIL</code> is encountered, <code>T</code> is returned
immediately. Else <code>NIL</code> is returned. <code>(nand ..)</code> is
equivalent to <code>(not (and ..))</code>.

<p><pre><code>
: (nand (lt0 7) (read))
-> T
: (nand (lt0 -7) (read))
abc
-> NIL
: (nand (lt0 -7) (read))
NIL
-> T
</code></pre>

<p><dt><a name="need"><code>(need 'cnt ['lst ['any]]) -> lst</code></a>
<dd>Produces a list of at least <code>cnt</code> elements. When called without
optional arguments, a list of <code>cnt</code> <code>NIL</code>'s is returned.
When <code>lst</code> is given, it is extended to the left (if <code>cnt</code>
is positive) or (destructively) to the right (if <code>cnt</code> is negative)
with <code>any</code> elements.

<p><pre><code>
: (need 5)
-> (NIL NIL NIL NIL NIL)            # Allocate 5 cells
: (need 5 '(a b c))
-> (NIL NIL a b c)
: (need -5 '(a b c))
-> (a b c NIL NIL)
: (need 5 '(a b c) " ")             # String alignment
-> (" " " " a b c)
</code></pre>

<p><dt><a name="new"><code>(new ['flg|num] ['typ ['any ..]]) -> sym</code></a>
<dd>Creates and returns a new object. If <code>flg</code> is given and
non-<code>NIL</code>, the new object will be an external symbol (created in the
corresponding database file if <code>num</code> is given). <code>typ</code>
(typically a list of classes) is assigned to the <code>VAL</code>, and the
initial <code>T</code> message is sent with the arguments <code>any</code> to
the new object. See also <code><a href="#box">box</a></code>.

<p><pre><code>
: (new)
-> $134426427
: (new T '(+Address))
-> {1A;3}
</code></pre>

<p><dt><a name="next"><code>(next) -> any</code></a>
<dd>Can only be used inside functions with a variable number of arguments (with
<code>@</code>). Returns the next argument from the internal list. See also
<code><a href="#args">args</a></code>, <code><a href="#arg">arg</a></code>,
<code><a href="#rest">rest</a></code>, and <code><a
href="#pass">pass</a></code>.

<p><pre><code>
: (de foo @ (println (next)))          # Print next argument
-> foo
: (foo)
NIL
-> NIL
: (foo 123)
123
-> 123
</code></pre>

<p><dt><a name="nil"><code>(nil . prg) -> NIL</code></a>
<dd>Executes <code>prg</code>, and returns <code>NIL</code>. See also <code><a
href="#t">t</a></code>, <code><a href="#prog">prog</a></code>, <code><a
href="#prog1">prog1</a></code> and <code><a href="#prog2">prog2</a></code>.

<p><pre><code>
: (nil (println 'Ok))
Ok
-> NIL
</code></pre>

<p><dt><a name="nond"><code>(nond (('any1 . prg1) ('any2 . prg2) ..)) -> any</code></a>
<dd>Negated ("non-cond") multi-way conditional: If any of the <code>anyN</code>
conditions evaluates to <code>NIL</code>, <code>prgN</code> is executed and the
result returned. Otherwise (all conditions evaluate to non-<code>NIL</code>),
<code>NIL</code> is returned. See also <code><a href="#cond">cond</a></code>,
<code><a href="#ifn">ifn</a></code> and <code><a
href="#unless">unless</a></code>.

<p><pre><code>
: (nond
   ((= 3 3) (println 1))
   ((= 3 4) (println 2))
   (NIL (println 3)) )
2
-> 2
</code></pre>

<p><dt><a name="nor"><code>(nor 'any ..) -> flg</code></a>
<dd>Logical NOR. The expressions <code>any</code> are evaluated from left to
right. If a non-<code>NIL</code> value is encountered, <code>NIL</code> is
returned immediately. Else <code>T</code> is returned. <code>(nor ..)</code> is
equivalent to <code>(not (or ..))</code>.

<p><pre><code>
: (nor (lt0 7) (= 3 4))
-> T
</code></pre>

<p><dt><a name="not"><code>(not 'any) -> flg</code></a>
<dd>Logical negation. Returns <code>T</code> if <code>any</code> evaluates to
<code>NIL</code>.

<p><pre><code>
: (not (== 'a 'a))
-> NIL
: (not (get 'a 'a))
-> T
</code></pre>

<p><dt><a name="nth"><code>(nth 'lst 'cnt ..) -> lst</code></a>
<dd>Returns the tail of <code>lst</code> starting from the <code>cnt</code>'th
element of <code>lst</code>. Successive <code>cnt</code> arguments operate on
the results in the same way. <code>(nth 'lst 2)</code> is equivalent to
<code>(cdr 'lst)</code>.

<p><pre><code>
: (nth '(a b c d) 2)
-> (b c d)
: (nth '(a (b c) d) 2 2)
-> (c)
: (cdadr '(a (b c) d))
-> (c)
</code></pre>

<p><dt><a name="numQ"><code>(num? 'any) -> num | NIL</code></a>
<dd>Returns <code>any</code> when the argument <code>any</code> is a number,
otherwise <code>NIL</code>.

<p><pre><code>
: (num? 123)
-> 123
: (num? (1 2 3))
-> NIL
</code></pre>


<p><hr>
<h3><a name="o-foo">O</a></h3>

<p><dt><a name="off"><code>(off sym ..) -> NIL</code></a>
<dd>Stores <code>NIL</code> in the <code>VAL</code>'s of all argument symbols
<code>sym</code>. See also <code><a href="#on">on</a></code>, <code><a
href="#onOff">onOff</a></code>, <code><a href="#zero">zero</a></code> and
<code><a href="#one">one</a></code>.

<p><pre><code>
: (off A B)
-> NIL
: A
-> NIL
: B
-> NIL
</code></pre>

<p><dt><a name="offset"><code>(offset 'lst1 'lst2) -> cnt | NIL</code></a>
<dd>Returns the <code>cnt</code> position of the tail list <code>lst1</code> in
<code>lst2</code>, or <code>NIL</code> if it is not found. See also <code><a
href="#index">index</a></code>.

<p><pre><code>
: (offset '(c d e f) '(a b c d e f))
-> 3
: (offset '(c d e) '(a b c d e f))
-> NIL
</code></pre>

<p><dt><a name="on"><code>(on sym ..) -> T</code></a>
<dd>Stores <code>T</code> in the <code>VAL</code>'s of all argument symbols
<code>sym</code>. See also <code><a href="#off">off</a></code>, <code><a
href="#onOff">onOff</a></code>, <code><a href="#zero">zero</a></code> and
<code><a href="#one">one</a></code>.

<p><pre><code>
: (on A B)
-> T
: A
-> T
: B
-> T
</code></pre>

<p><dt><a name="one"><code>(one sym ..) -> 1</code></a>
<dd>Stores <code>1</code> in the <code>VAL</code>'s of all argument symbols
<code>sym</code>. See also <code><a href="#zero">zero</a></code>, <code><a
href="#on">on</a></code>, <code><a href="#off">off</a></code> and <code><a
href="#onOff">onOff</a></code>.

<p><pre><code>
: (one A B)
-> 1
: A
-> 1
: B
-> 1
</code></pre>

<p><dt><a name="onOff"><code>(onOff sym ..) -> flg</code></a>
<dd>Logical negates the <code>VAL</code>'s of all argument symbols
<code>sym</code>. Returns the new value of the last symbol. See also <code><a
href="#on">on</a></code>, <code><a href="#off">off</a></code>, <code><a
href="#zero">zero</a></code> and <code><a href="#one">one</a></code>.

<p><pre><code>
: (onOff A B)
-> T
: A
-> T
: B
-> T
: (onOff A B)
-> NIL
: A
-> NIL
: B
-> NIL
</code></pre>

<p><dt><a name="open"><code>(open 'sym) -> cnt | NIL</code></a>
<dd>Opens the file <code>sym</code> in read/write mode, and returns a file
descriptor <code>cnt</code> (or <code>NIL</code> on error). If the file does not
exist, it is created. The file descriptor can be used in subsequent calls to
<code><a href="#in">in</a></code> and <code><a href="#out">out</a></code>. See
also <code><a href="#close">close</a></code>.

<p><pre><code>
: (open "x")
-> 3
</code></pre>

<p><dt><a name="opt"><code>(opt) -> sym</code></a>
<dd>Return the next command line argument (option) as a string, and remove it
from the remaining command line arguments. See also <code><a
href="#invoc">Invocation</a></code> and <code><a href="#argv">argv</a></code>.

<p><pre><code>
$ ./p  -"de f () (println 'opt (opt))"  -f abc  -bye
opt "abc"
</code></pre>

<p><dt><a name="or"><code>(or 'any ..) -> any</code></a>
<dd>Logical OR. The expressions <code>any</code> are evaluated from left to
right. If a non-<code>NIL</code> value is encountered, it is returned
immediately. Else the result of the last expression is returned.

<p><pre><code>
: (or (= 3 3) (read))
-> T
: (or (= 3 4) (read))
abc
-> abc
</code></pre>

<p><dt><a name="out"><code>(out 'any . prg) -> any</code></a>
<dd>Opens <code>any</code> as output channel during the execution of
<code>prg</code>. The current output channel will be saved and restored
appropriately. If the argument is <code>NIL</code>, standard output is used. If
the argument is a symbol, it is used as a file name (opened in "append" mode if
the first character is "<code>+</code>"). If it is a number, it is used as the
descriptor of an open file. Otherwise (if it is a list), it is taken as a
command with arguments, and a pipe is opened for output. See also <code><a
href="#call">call</a></code>, <code><a href="#in">in</a></code>, <code> <a
href="#pipe">pipe</a></code>, <code> <a href="#ctl">ctl</a></code> and <code><a
href="#load">load</a></code>.

<p><pre><code>
: (out "a" (println 123 '(a b c) 'def))      # Write one line to file "a"
-> def
</code></pre>


<p><hr>
<h3><a name="p-foo">P</a></h3>

<p><dt><a name="pack"><code>(pack 'any ..) -> sym</code></a>
<dd>Returns a transient symbol whose name is concatenated from all arguments
<code>any</code>. A <code>NIL</code> arguments contributes nothing to the result
string, a number is converted to a digit string, a symbol supplies the
characters of its name, and for a list its elements are taken. See also <code><a
href="#text">text</a></code> and <code><a href="#glue">glue</a></code>.

<p><pre><code>
: (pack 'car " is " 1 '(" symbol " name))
-> "car is 1 symbol name"
</code></pre>

<p><dt><a name="pair"><code>(pair 'any) -> any</code></a>
<dd>Returns <code>any</code> when the argument a cons pair cell. See also
<code><a href="#atom">atom</a></code>.

<p><pre><code>
: (pair NIL)
-> NIL
: (pair (1 . 2))
-> (1 . 2)
: (pair (1 2 3))
-> (1 2 3)
</code></pre>

<p><dt><a name="pass"><code>(pass 'fun ['any ..]) -> any</code></a>
<dd>Passes to <code>fun</code> all arguments <code>any</code>, and all remaining
variable arguments (<code>@</code>) as they would be returned by <code><a
href="#rest">rest</a></code>. <code>(pass 'fun 'any)</code> is equivalent to
<code>(apply 'fun (cons 'any (rest)))</code>. See also <code><a
href="#apply">apply</a></code>.

<p><pre><code>
: (de bar (A B . @)
   (println 'bar A B (rest)) )
-> bar
: (de foo (A B . @)
   (println 'foo A B)
   (pass bar 1)
   (pass bar 2) )
-> foo
: (foo 'a 'b 'c 'd 'e 'f)
foo a b
bar 1 c (d e f)
bar 2 c (d e f)
-> (d e f)
</code></pre>

<p><dt><a name="path"><code>(path 'sym) -> sym</code></a>
<dd>Substitutes any leading "<code>@</code>" character in the <code>sym</code>
argument with the <u>Pico Lisp Home Directory</u>, as it was remembered during
interpreter startup. Optionally, the name may be preceded by a "<code>+</code>"
character (as used by <code><a href="#out">out</a></code>). This mechanism is
used internally by all I/O functions. See also <code><a
href="#invoc">Invocation</a></code>.

<p><pre><code>
$ /usr/bin/picolisp /usr/lib/picolisp/lib.l
: (path "a/b/c")
-> "a/b/c"
: (path "@a/b/c")
-> "/usr/lib/picolisp/a/b/c"
: (path "+@a/b/c")
-> "+/usr/lib/picolisp/a/b/c"
</code></pre>

<p><dt><a name="patQ"><code>(pat? 'any) -> sym | NIL</code></a>
<dd>Returns <code>any</code> when the argument <code>any</code> is a symbol
whose name starts with an at-mark "<code>@</code>", otherwise <code>NIL</code>.

<p><pre><code>
: (pat? '@)
-> @
: (pat? "@Abc")
-> "@Abc"
: (pat? "ABC")
-> NIL
: (pat? 123)
-> NIL
</code></pre>

<p><dt><a name="peek"><code>(peek) -> sym</code></a>
<dd>Single character look-ahead: Returns the same character as the next call to
<code><a href="#char">char</a></code> would return. See also <code><a
href="#skip">skip</a></code>.

<p><pre><code>
$ cat a
# Comment
abcd
$ ./p dbg.l
: (in "a" (list (peek) (char)))
-> ("#" "#")
</code></pre>

<p><dt><a name="pick"><code>(pick 'fun 'lst ..) -> any</code></a>
<dd>Applies <code>fun</code> to successive elements of <code>lst</code> until
non-<code>NIL</code> is returned. Returns that value, or <code>NIL</code> if
<code>fun</code> did not return non-<code>NIL</code> for any element of
<code>lst</code>. When additional <code>lst</code> arguments are given, their
elements are also passed to <code>fun</code>. See also <code><a
href="#seek">seek</a></code>, <code><a href="#find">find</a></code>.

<p><pre><code>
: (put 'D 'str "Hello")
-> "Hello"
: (pick '((X) (get X 'str)) '(A B C D E F))
-> "Hello"
</code></pre>

<p><dt><a name="pipe"><code>(pipe exe) -> cnt<br>
(pipe exe . prg) -> any</code></a>
<dd>Executes <code>exe</code> in a <code><a href="#fork">fork</a></code>'ed
child process (which terminates thereafter). In the first form,
<code>pipe</code> just returns a file descriptor to read from the standard
output of that process. In the second form, it opens the standard output of that
process as input channel during the execution of <code>prg</code>. The current
input channel will be saved and restored appropriately. See also <code><a
href="#in">in</a></code> and <code><a href="#out">out</a></code>.

<p><pre><code>
: (pipe                                # equivalent to 'any'
   (prinl "(a b # Comment^Jc d)")         # (child process)
   (read) )                               # (parent process)
-> (a b c d)
: (pipe                                # pipe through an external program
   (out '(tr "[a-z]" "[A-Z]")             # (child process)
      (prinl "abc def ghi") )
   (line T) )                             # (parent process)
-> "ABC DEF GHI"
</code></pre>

<p><dt><a name="poll"><code>(poll 'cnt) -> flg</code></a>
<dd>Checks for the availability of data for reading on the file descriptor
<code>cnt</code>. See also <code><a href="#open">open</a></code>, <code><a
href="#in">in</a></code> and <code><a href="#close">close</a></code>.

<p><pre><code>
: (and (poll *Fd) (in *Fd (read)))  # Prevent blocking
</code></pre>

<p><dt><a name="pool"><code>(pool ['sym1 ['lst] ['sym2]]) -> flg</code></a>
<dd>Opens the file <code>sym1</code> as a database file in read/write mode. If
the file does not exist, it is created. A currently open database is closed.
<code>lst</code> is a list of block size scale factors (i.e. numbers),
defaulting to (2) (for a single file with a 256 byte block size). If
<code>lst</code> is given, an individual database file is opened for each item.
If <code>sym2</code> is non-<code>NIL</code>, it is opened in append-mode as a
journal file. Returns <code>T</code> when successful. See also <code><a
href="#journal">journal</a></code>.

<p><pre><code>
: (pool "/dev/hda2")
-> T
</code></pre>

<p><dt><a name="pop"><code>(pop 'var) -> any</code></a>
<dd>Pops the first element (<code>CAR</code>) from the stack in
<code>var</code>. See also <code><a href="#push">push</a></code>, <code><a
href="#queue">queue</a></code>, <code><a href="#cut">cut</a></code>, <code><a
href="#del">del</a></code> and <code><a href="#fifo">fifo</a></code>.

<p><pre><code>
: (setq S '((a b c) (1 2 3)))
-> ((a b c) (1 2 3))
: (pop S)
-> a
: (pop (cdr S))
-> 1
: (pop 'S)
-> (b c)
: S
-> ((2 3))
</code></pre>

<p><dt><a name="port"><code>(port ['T] 'cnt|(cnt . cnt) ['var]) -> cnt</code></a>
<dd>Opens a TCP-Port <code>cnt</code> (or a UDP-Port if the first argument is
<code>T</code>), and returns a socket descriptor suitable as an argument for
<code><a href="#listen">listen</a></code> or <code><a
href="#accept">accept</a></code> (or <code><a href="#udp">udp</a></code>,
respectively). If <code>cnt</code> is zero, some free port number is allocated.
If a pair of <code>cnt</code>s is given instead, it should be a range of numbers
which are tried in turn. When <code>var</code> is given, it is bound to the port
number.

<p><pre><code>
: (port 0 'A)                       # Allocate free port
-> 4
: A
-> 1034                             # Got 1034
: (port (4000 . 4008) 'A)           # Try one of these ports
-> 5
: A
-> 4002
</code></pre>

<p><dt><a name="pr"><code>(pr 'any ..) -> any</code></a>
<dd>Binary print: Prints all <code>any</code> arguments to the current output
channel in encoded binary format. See also <code><a href="#rd">rd</a></code>,
<code><a href="#wr">wr</a></code> and <code><a href="#rpc">rpc</a></code>.

<p><pre><code>
: (out "x" (pr 7 "abc" (1 2 3) 'a))          # Print to "x"
-> a
: (hd "x")
00000000  04 0E 0E 61 62 63 01 04 02 04 04 04 06 03 05 61  ...abc.........a
-> NIL
</code></pre>

<p><dt><a name="preQ"><code>(pre? 'sym1 'sym2) -> flg</code></a>
<dd>Returns non-<code>NIL</code> when the name of the first symbol
<code>sym1</code> is a prefix string of the name of the second symbol
<code>sym2</code>. See also <code><a href="#subQ">sub?</a></code>.

<p><pre><code>
: (pre? "abc" "abcdef")
-> T
: (pre? "def" "abcdef")
-> NIL
: (pre? "" "abcdef")
-> T
</code></pre>

<p><dt><a name="prin"><code>(prin 'any ..) -> any</code></a>
<dd>Prints the string representation of all <code>any</code> arguments to the
current output channel. No space or newline is printed between individual items,
of after the last item. For lists, all elements are <code>prin</code>'ted
recursively. See also <code><a href="#prinl">prinl</a></code>.

<p><pre><code>
: (prin 'abc 123 '(a 1 b 2))
abc123a1b2-> (a 1 b 2)
</code></pre>

<p><dt><a name="prinl"><code>(prinl 'any ..) -> any</code></a>
<dd>Prints the string representation of all <code>any</code> arguments to the
current output channel, followed by a newline. No space or newline is printed
between individual items. For lists, all elements are <code>prin</code>'ted
recursively. See also <code><a href="#prin">prin</a></code>.

<p><pre><code>
: (prinl 'abc 123 '(a 1 b 2))
abc123a1b2
-> (a 1 b 2)
</code></pre>

<p><dt><a name="print"><code>(print 'any ..) -> any</code></a>
<dd>Prints all <code>any</code> arguments to the current output channel. If
there is more than one argument, a space is printed between successive
arguments. No space or newline is printed after the last item. See also <code><a
href="#println">println</a></code>, <code><a href="#printsp">printsp</a></code>,
<code><a href="#sym">sym</a></code> and <code><a href="#str">str</a></code>

<p><pre><code>
: (print 123)
123-> 123
: (print 1 2 3)
1 2 3-> 3
: (print '(a b c) 'def)
(a b c) def-> def
</code></pre>

<p><dt><a name="println"><code>(println 'any ..) -> any</code></a>
<dd>Prints all <code>any</code> arguments to the current output channel,
followed by a newline. If there is more than one argument, a space is printed
between successive arguments. See also <code><a href="#print">print</a></code>,
<code><a href="#printsp">printsp</a></code>.

<p><pre><code>
: (println '(a b c) 'def)
(a b c) def
-> def
</code></pre>

<p><dt><a name="printsp"><code>(printsp 'any ..) -> any</code></a>
<dd>Prints all <code>any</code> arguments to the current output channel,
followed by a space. If there is more than one argument, a space is printed
between successive arguments. See also <code><a href="#print">print</a></code>,
<code><a href="#println">println</a></code>.

<p><pre><code>
: (printsp '(a b c) 'def)
(a b c) def -> def
</code></pre>

<p><dt><a name="prog"><code>(prog . prg) -> any</code></a>
<dd>Executes <code>prg</code>, and returns the result of the last expression.
See also <code><a href="#nil">nil</a></code>, <code><a href="#t">t</a></code>,
<code><a href="#prog1">prog1</a></code> and <code><a
href="#prog2">prog2</a></code>.

<p><pre><code>
: (prog (print 1) (print 2) (print 3))
123-> 3
</code></pre>

<p><dt><a name="prog1"><code>(prog1 'any1 . prg) -> any1</code></a>
<dd>Executes all arguments, and returns the result of the first expression
<code>any1</code>. See also <code><a href="#nil">nil</a></code>, <code><a
href="#t">t</a></code>, <code><a href="#prog">prog</a></code> and <code><a
href="#prog2">prog2</a></code>.

<p><pre><code>
: (prog1 (print 1) (print 2) (print 3))
123-> 1
</code></pre>

<p><dt><a name="prog2"><code>(prog2 'any1 'any2 . prg) -> any2</code></a>
<dd>Executes all arguments, and returns the result of the second expression
<code>any2</code>. See also <code><a href="#nil">nil</a></code>, <code><a
href="#t">t</a></code>, <code><a href="#prog">prog</a></code> and <code><a
href="#prog1">prog1</a></code>.

<p><pre><code>
: (prog2 (print 1) (print 2) (print 3))
123-> 2
</code></pre>

<p><dt><a name="prop"><code>(prop 'sym1|lst ['sym2|cnt ..] 'sym) -> lst|sym</code></a>
<dd>Fetches a property for a property key <code>sym</code> from a symbol. That
symbol is <code>sym1</code> (if no other arguments are given), or a symbol found
by applying the <code><a href="#get">get</a></code> algorithm to
<code>sym1|lst</code> and the following arguments. The property (the cell, not
just its value) is returned, suitable for direct (destructive) manipulations.

<p><pre><code>
: (put 'X 'cnt 0)
-> 0
: (prop 'X 'cnt)
-> (0 . cnt)
: (inc (prop 'X 'cnt))        # Directly manipulate the property value
-> 1
: (get 'X 'cnt)
-> 1
</code></pre>

<p><dt><a name="protect"><code>(protect . prg) -> any</code></a>
<dd>Executes <code>prg</code>, and returns the result of the last expression. If
a SIGTERM signal is received during that time, termination of the process will
be delayed until the execution of <code>prg</code> is completed. See also
<code><a href="#kill">kill</a></code>.

<p><pre><code>
: (protect (journal "db1.log" "db2.log"))
-> T
</code></pre>

<p><dt><a name="prove"><code>(prove 'lst ['lst]) -> lst</code></a>
<dd>The <a href="#pilog">Pilog</a> interpreter. Tries to prove the query list in
the first argument, and returns an association list of symbol-value pairs, or
<code>NIL</code> if not successful. The query list is modified as a side effect,
allowing subsequent calls to <code>prove</code> for further results. The
optional second argument may contain a list of symbols; in that case the
successful matches of rules defined for these symbols will be traced. See also
<code><a href="#goal">goal</a></code>, <code><a href="#lookup">-&gt</a></code>
and <code><a href="#unify">unify</a></code>.

<p><pre><code>
: (prove (goal '((equal 3 3))))
-> T
: (prove (goal '((equal 3 @X))))
-> ((@X . 3))
: (prove (goal '((equal 3 4))))
-> NIL
</code></pre>

<p><dt><a name="push"><code>(push 'var 'any ..) -> any</code></a>
<dd>Implements a stack using a list in <code>var</code>. The <code>any</code>
arguments are cons'ed in front of the value list. See also <code><a
href="#push1">push1</a></code>, <code><a href="#pop">pop</a></code>, <code><a
href="#queue">queue</a></code> and <code><a href="#fifo">fifo</a></code>.

<p><pre><code>
: (push 'S 3)              # Use the VAL of 'S' as a stack
-> 3
: S
-> (3)
: (push 'S 2)
-> 2
: (push 'S 1)
-> 1
: S
-> (1 2 3)
: (push S 999)             # Now use the CAR of the list in 'S'
-> 999
: (push S 888 777)
-> 777
: S
-> ((777 888 999 . 1) 2 3)
</code></pre>

<p><dt><a name="push1"><code>(push1 'var 'any ..) -> any</code></a>
<dd>Maintains a unique list in <code>var</code>. Each <code>any</code> argument
is cons'ed in front of the value list only if it is not already a <code><a
href="#member">member</a></code> of that list. See also <code><a
href="#push">push</a></code>, <code><a href="#pop">pop</a></code> and <code><a
href="#queue">queue</a></code>.

<p><pre><code>
: (push1 'S 1 2 3)
-> 3
: S
-> (3 2 1)
: (push1 'S 2 4)
-> 4
: S
-> (4 3 2 1)
</code></pre>

<p><dt><a name="put"><code>(put 'sym1|lst ['sym2|cnt ..] 'sym 'any) -> any</code></a>
<dd>Stores a new value <code>any</code> for a property key <code>sym</code> in a
symbol. That symbol is <code>sym1</code> (if no other arguments are given), or a
symbol found by applying the <code><a href="#get">get</a></code> algorithm to
<code>sym1|lst</code> and the following arguments.

<p><pre><code>
: (put 'X 'a 1)
-> 1
: (get 'X 'a)
-> 1
: (prop 'X 'a)
-> (1 . a)
</code></pre>

<p><dt><a name="putl"><code>(putl 'sym1|lst1 ['sym2|cnt ..] 'lst) -> lst</code></a>
<dd>Stores a complete new property list <code>lst</code> in a symbol. That
symbol is <code>sym1</code> (if no other arguments are given), or a symbol found
by applying the <code><a href="#get">get</a></code> algorithm to
<code>sym1|lst1</code> and the following arguments. All previously defined
properties for that symbol are lost. See also <code><a
href="#getl">getl</a></code> and <code><a href="#maps">maps</a></code>.

<p><pre><code>
: (putl 'X '((123 . a) flg ("Hello" . b)))
-> ((123 . a) flg ("Hello" . b))
: (get 'X 'a)
-> 123
: (get 'X 'b)
-> "Hello"
: (get 'X 'flg)
-> T
</code></pre>

<p><dt><a name="pwd"><code>(pwd) -> sym</code></a>
<dd>Returns the path to the current working directory. See also <code><a
href="#dir">dir</a></code> and <code><a href="#cd">cd</a></code>.

<p><pre><code>
: (pwd)
-> "/home/app/"
</code></pre>


<p><hr>
<h3><a name="q-foo">Q</a></h3>

<p><dt><a name="quote"><code>(quote . any) -> any</code></a>
<dd>Returns <code>any</code> unevaluated. The reader recognizes the single quote
char <code>'</code> as a macro for this function. See also <code><a
href="#lit">lit</a></code>.

<p><pre><code>
: 'a
-> a
: '(foo a b c)
-> (foo a b c)
: (quote (quote (quote a)))
-> ('('(a)))
</code></pre>

<p><dt><a name="queue"><code>(queue 'var 'any) -> any</code></a>
<dd>Implements a queue using a list in <code>var</code>. The <code>any</code>
argument is (destructively) concatenated to the end of the value list. See also
<code><a href="#push">push</a></code>, <code><a href="#pop">pop</a></code> and
<code><a href="#fifo">fifo</a></code>.

<p><pre><code>
: (queue 'A 1)
-> 1
: (queue 'A 2)
-> 2
: (queue 'A 3)
-> 3
: A
-> (1 2 3)
: (pop 'A)
-> 1
: A
-> (2 3)
</code></pre>

<p><dt><a name="quit"><code>(quit ['any ['any]])</code></a>
<dd>Stops current execution. If no arguments are given, all pending <code><a
href="#finally">finally</a></code> expressions are executed and control is
returned to the top level read-eval-print loop. Otherwise, an error handler is
entered. The first argument can be some error message, and the second might be
the reason for the error. See also <code><a href="#errors">Error
Handling</a></code>.

<p><pre><code>
: (de foo (X) (quit "Sorry, my error" X))
-> foo
: (foo 123)                                  # 'X' is bound to '123'
123 -- Sorry, my error                       # Error entered
? X                                          # Inspect 'X'
-> 123
?                                            # Empty line: Exit
:
</code></pre>


<p><hr>
<h3><a name="r-foo">R</a></h3>

<p><dt><a name="rand"><code>(rand ['cnt1 'cnt2] | ['T]) -> cnt | flg</code></a>
<dd>Returns a pseudo random number in the range cnt1 .. cnt2 (or -2147483648 ..
+2147483647 if no arguments are given). If the argument is <code>T</code>, a
boolean value <code>flg</code> is returned. See also <code><a
href="#seed">seed</a></code>.

<p><pre><code>
: (rand 3 9)
-> 3
: (rand 3 9)
-> 7
</code></pre>

<p><dt><a name="rank"><code>(rank 'any 'lst ['flg]) -> lst</code></a>
<dd>Searches a ranking list. <code>lst</code> should be sorted. Returns the
element from <code>lst</code> with a maximal <code>CAR</code> less or equal to
<code>any</code> (if <code>flg</code> is <code>NIL</code>), or with a minimal
<code>CAR</code> greater or equal to <code>any</code> (if <code>flg</code> is
non-<code>NIL</code>), or <code>NIL</code> if no match is found. See also <a
href="#cmp">Comparing</a>.

<p><pre><code>
: (rank 0 '((1 . a) (100 . b) (1000 . c)))
-> NIL
: (rank 50 '((1 . a) (100 . b) (1000 . c)))
-> (1 . a)
: (rank 100 '((1 . a) (100 . b) (1000 . c)))
-> (100 . b)
: (rank 300 '((1 . a) (100 . b) (1000 . c)))
-> (100 . b)
: (rank 9999 '((1 . a) (100 . b) (1000 . c)))
-> (1000 . c)
: (rank 50 '((1000 . a) (100 . b) (1 . c)) T)
-> (100 . b)
</code></pre>

<p><dt><a name="raw"><code>(raw ['flg]) -> flg</code></a>
<dd>Console mode control function. When called without arguments, it returns the
current console mode (<code>NIL</code> for "cooked mode"). Otherwise, the
console is set to the new state. See also <code><a href="#key">key</a></code>.

<p><pre><code>
$ ./p
: (raw)
-> NIL
$ ./p dbg.l
: (raw)
-> T
</code></pre>

<p><dt><a name="rd"><code>(rd ['sym]) -> any<br>
(rd 'cnt) -> num | NIL</code></a>
<dd>Binary read: Reads one item from the current input channel in encoded binary
format. When called with a <code>cnt</code> argument (second form), that number
of raw bytes (in big endian format if <code>cnt</code> is positive) is read as a
single number. Upon end of file, if the <code>sym</code> argument is given, it
is returned, otherwise <code>NIL</code>. See also <code><a
href="#pr">pr</a></code> and <code><a href="#wr">wr</a></code>.

<p><pre><code>
: (out "x" (pr 'abc "EOF" 123 "def"))
-> "def"
: (in "x" (rd))
-> abc
: (in "x"
   (make
      (use X
         (until (== "EOF" (setq X (rd "EOF")))  # '==' detects end of file
            (link X) ) ) ) )
-> (abc "EOF" 123 "def")  # as opposed to reading a symbol "EOF"

: (in "/dev/urandom" (rd 20))
-> 396737673456823753584720194864200246115286686486
</code></pre>

<p><dt><a name="read"><code>(read ['sym1 ['sym2]]) -> any</code></a>
<dd>Reads one item from the current input channel. <code>NIL</code> is returned
upon end of file. When called without arguments, an arbitrary Lisp expression is
read. Otherwise, a token (a number, or an internal or transient symbol) is read.
In that case, <code>sym1</code> specifies which set of characters to accept for
internal symbols (in addition to the standard alphanumerical characters), and
<code>sym2</code> an optional comment character. See also <code><a
href="#any">any</a></code>, <code><a href="#str">str</a></code>, <code><a
href="#skip">skip</a></code> and <code><a href="#eof">eof</a></code>.

<p><pre><code>
: (list (read) (read) (read))    # Read three things from console
123                              # a number
abcd                             # a symbol
(def                             # and a list
ghi
jkl
)
-> (123 abcd (def ghi jkl))
: (make (while (read "_" "#") (link @)))
abc = def_ghi("xyz"+-123) # Comment
""
-> (abc "=" def_ghi "(" "xyz" "+" -123 ")")
</code></pre>

<p><dt><a name="rel"><code>(rel sym lst [any ..]) -> any</code></a>
<dd>Defines a relation <code>sym</code> for the current class
<code>*Class</code>, using <code>lst</code> as the list of classes for that
relation, and possibly additional arguments <code>any</code> for its
initialization.

<p><pre><code>
(class +Person +Entity)
(rel nm     (+List +Ref +String))               # Names
(rel tel    (+Ref +String))                     # Telephone
(rel adr    (+Joint) prs (+Address))            # Address

(class +Address +Entity)
(rel Cit    (+Need +Hook +Link) (+City))        # City
(rel str    (+List +Ref +String) Cit)           # Street
(rel prs    (+List +Joint) adr (+Person))       # Inhabitants

(class +City +Entity)
(rel nm     (+List +Ref +String))               # Zip / Names
</code></pre>

<p><dt><a name="replace"><code>(replace 'lst 'any1 'any2 ..) -> lst</code></a>
<dd>Replaces in <code>lst</code> all occurrences of <code>any1</code> with
<code>any2</code>. For optional additional argument pairs, this process is
repeated.

<p><pre><code>
: (replace '(a b b a) 'a 'A)
-> (A b b A)
: (replace '(a b b a) 'b 'B)
-> (a B B a)
: (replace '(a b b a) 'a 'B 'b 'A)
-> (B A A B)
</code></pre>

<p><dt><a name="rest"><code>(rest) -> lst</code></a>
<dd>Can only be used inside functions with a variable number of arguments (with
<code>@</code>). Returns the the list of all remaining arguments from the
internal list. See also <code><a href="#args">args</a></code>, <code><a
href="#next">next</a></code>, <code><a href="#arg">arg</a></code> and <code><a
href="#pass">pass</a></code>.

<p><pre><code>
: (de foo @ (println (rest)))
-> foo
: (foo 1 2 3)
(1 2 3)
-> (1 2 3)
</code></pre>

<p><dt><a name="reverse"><code>(reverse 'lst) -> lst</code></a>
<dd>Returns a reversed copy of <code>lst</code>. See also <code><a
href="#flip">flip</a></code>.

<p><pre><code>
: (reverse (1 2 3 4))
-> (4 3 2 1)
</code></pre>

<p><dt><a name="rewind"><code>(rewind) -> flg</code></a>
<dd>Sets the file position indicator for the current output stream to the
beginning of the file, and truncates the file length to zero. Returns
<code>T</code> when successful. See also <code><a
href="#flush">flush</a></code>.

<p><pre><code>
</code></pre>

<p><dt><a name="rollback"><code>(rollback) -> flg</code></a>
<dd>Cancels a transaction, by discarding all modifications of external symbols.
For nested transactions, only the changes since the last call to <code><a
href="#begin">begin</a></code> are discarded. Returns <code>T</code> when the
topmost transaction is cancelled. See also <code><a
href="#commit">commit</a></code>.

<p><pre><code>
: (pool "db")
-> T
: (begin)
-> T
: (rollback)            # Rollback second level
-> NIL
: (rollback)            # Rollback top level
-> T
</code></pre>

<p><dt><a name="rot"><code>(rot 'lst ['cnt]) -> lst</code></a>
<dd>Rotate: The contents of the cells of <code>lst</code> are (destructively)
shifted right, and the value from the last cell is stored in the first cell.
Without the optional <code>cnt</code> argument, the whole list is rotated.
Otherwise only the first <code>cnt</code> elements are rotated.

<p><pre><code>
: (rot (1 2 3 4))             # Rotate all four elements
-> (4 1 2 3)
: (rot (1 2 3 4 5 6) 3)       # Rotate only the first three elements
-> (3 1 2 4 5 6)
</code></pre>

<p><dt><a name="rpc"><code>(rpc 'sym ['any ..]) -> flg</code></a>
<dd><i>Rapid</i> (or <i>remote</i>) procedure call: Send an executable list
<code>(sym any ..)</code> via standard output in encoded binary format. See also
<code><a href="#pr">pr</a></code>, <code><a href="#pipe">pipe</a></code>,
<code><a href="#tell">tell</a></code> and <code><a href="#hear">hear</a></code>.

<p><pre><code>
: (hear (pipe (do 3 (wait 2000) (rpc 'println ''Ok))))
-> 3
: Ok  # every two seconds
Ok
Ok
</code></pre>

<p><dt><a name="run"><code>(run 'any ['cnt]) -> any</code></a>
<dd>If <code>any</code> is an atom, <code>run</code> behaves like
<code>eval</code>. Otherwise <code>any</code> is a list, which is evaluated in
sequence. The last result is returned. If a binding environment offset
<code>cnt</code> is given, that evaluation takes place in the corresponding
environment. See also <code><a href="#eval">eval</a></code> and <code><a
href="#up">up</a></code>.

<p><pre><code>
: (run '((println (+ 1 2 3)) (println 'Ok)))
6
Ok
-> Ok
</code></pre>


<p><hr>
<h3><a name="s-foo">S</a></h3>

<p><dt><a name="sect"><code>(sect 'lst 'lst) -> lst</code></a>
<dd>Returns the intersection of the <code>lst</code> arguments. See also
<code><a href="#diff">diff</a></code>.

<p><pre><code>
: (sect (1 2 3 4) (3 4 5 6))
-> (3 4)
: (sect (1 2 3) (4 5 6))
-> NIL
</code></pre>

<p><dt><a name="seed"><code>(seed 'any) -> cnt</code></a>
<dd>Initializes the random generator's seed, and returns a pseudo random number
in the range -2147483648 .. +2147483647. See also <code><a
href="#rand">rand</a></code>.

<p><pre><code>
: (seed "init string")
-> 2015582081
: (rand)
-> -706917003
: (rand)
-> 1224196082
: (seed "init string")
-> 2015582081
: (rand)
-> -706917003
: (rand)
-> 1224196082
</code></pre>

<p><dt><a name="seek"><code>(seek 'fun 'lst ..) -> lst</code></a>
<dd>Applies <code>fun</code> to <code>lst</code> and all successive
<code>CDR</code>'s, until non-<code>NIL</code> is returned. Returns the tail of
<code>lst</code> starting with that element, or <code>NIL</code> if
<code>fun</code> did not return non-<code>NIL</code> for any element of
<code>lst</code>. When additional <code>lst</code> arguments are given, they are
passed to <code>fun</code> in the same way. See also <code><a
href="#find">find</a></code>, <code><a href="#pick">pick</a></code>.

<p><pre><code>
: (seek '((X) (> (car X) 9)) (1 5 8 12 19 22))
-> (12 19 22)
</code></pre>

<p><dt><a name="send"><code>(send 'msg 'obj ['any ..]) -> any</code></a>
<dd>Sends the message <code>msg</code> to the object <code>obj</code>,
optionally with arguments <code>any</code>. If the message cannot be located in
<code>obj</code>, its classes and superclasses, an error <code>"Bad
message"</code> is issued. See also <code><a href="#try">try</a></code> and
<code><a href="#method">method</a></code>.

<p><pre><code>
: (send 'stop> Dlg)  # Equivalent to (stop> Dlg)
-> NIL
</code></pre>

<p><dt><a name="seq"><code>(seq 'cnt|sym1 ['sym2 ['num]]) -> sym | num | NIL</code></a>
<dd>Sequential single step: Returns the <i>first</i> external symbol in the
<code>cnt</code>'th database file, or the <i>next</i> external symbol following
<code>sym1</code> in the database, or <code>NIL</code> when the end of the
database is reached. When <code>sym2</code> is given, the database is extended
up to (including the creation of) <code>sym2</code>. If <code>num</code> is
given, it should be the return value of a previous call to <code>seq</code>, and
is used as an internal free list link. See also <code><a
href="#free">free</a></code>.

<p><pre><code>
: (pool "db")
-> T
: (seq *DB)
-> {2}
: (seq @)
-> {3}
</code></pre>

<p><dt><a name="set"><code>(set 'var 'any ..) -> any</code></a>
<dd>Stores new values <code>any</code> in the <code>var</code> arguments.

<p><pre><code>
: (set 'L '(a b c)  (cdr L) '999)
-> 999
: L
-> (a 999 c)
</code></pre>

<p><dt><a name="setq"><code>(setq var 'any ..) -> any</code></a>
<dd>Stores new values <code>any</code> in the <code>var</code> arguments.

<p><pre><code>
: (setq  A 123  B (list A A))  # Set 'A' to 123, then 'B' to (123 123)
-> (123 123)
</code></pre>

<p><dt><a name="size"><code>(size 'any) -> cnt</code></a>
<dd>Returns the "size" of <code>any</code>. For numbers this is the number of
bytes needed for the value, for external symbols it is the number of bytes it
would occupy in the database, for other symbols it is the number of bytes
occupied in the UTF-8 representation of the name, and for lists it is the total
number of cells in this list and all its sublists. See also <code><a
href="#length">length</a></code>.

<p><pre><code>
: (size "abc")
-> 3
: (size "√§bc")
-> 4
: (size 123)
-> 1
: (size (1 (2) 3))
-> 4
</code></pre>

<p><dt><a name="skip"><code>(skip ['sym]) -> sym</code></a>
<dd>Skips all white space (and comments if <code>sym</code> is given) in the
input stream. Returns the next available character, or <code>NIL</code> upon end
of file. See also <code><a href="#peek">peek</a></code> and <code><a
href="#eof">eof</a></code>.

<p><pre><code>
$ cat a
# Comment
abcd
$ ./p dbg.l
: (in "a" (skip "#"))
-> "a"
</code></pre>

<p><dt><a name="sort"><code>(sort 'lst) -> lst</code></a>
<dd>Sorts <code>lst</code> by destructively exchanging its elements. See also <a
href="#cmp">Comparing</a>.

<p><pre><code>
: (sort '(a 3 1 (1 2 3) d b 4 T NIL (a b c) (x y z) c 2))
-> (NIL 1 2 3 4 a b c d (1 2 3) (a b c) (x y z) T)
</code></pre>

<p><dt><a name="space"><code>(space ['cnt]) -> cnt</code></a>
<dd>Prints <code>cnt</code> spaces, or a single space when <code>cnt</code> is
not given.

<p><pre><code>
: (space)
 -> T
: (space 1)
 -> T
: (space 2)
  -> T
</code></pre>

<p><dt><a name="spQ"><code>(sp? 'any) -> flg</code></a>
<dd>Returns <code>T</code> when the argument <code>any</code> is
<code>NIL</code>, or if it is a string (symbol) that consists only of whitespace
characters.

<p><pre><code>
: (sp? "  ")
-> T
: (sp? "ABC")
-> NIL
: (sp? 123)
-> NIL
</code></pre>

<p><dt><a name="split"><code>(split 'lst 'any ..) -> lst</code></a>
<dd>Splits <code>lst</code> at all places containing an element <code>any</code>
and returns the resulting list of sublists.

<p><pre><code>
: (split (1 a 2 b 3 c 4 d 5 e 6) 'e 3 'a)
-> ((1) (2 b) (c 4 d 5) (6))
: (mapcar pack (split (chop "The quick brown fox") " "))
-> ("The" "quick" "brown" "fox")
</code></pre>

<p><dt><a name="sqrt"><code>(sqrt 'num) -> num</code></a>
<dd>Returns the square root of the <code>num</code> argument.

<p><pre><code>
: (sqrt 64)
-> 8
: (sqrt 1000)
-> 31
: (sqrt 10000000000000000000000000000000000000000)
-> 100000000000000000000
</code></pre>

<p><dt><a name="state"><code>(state 'var ((sym|lst sym [. prg]) . prg) ..) -> any</code></a>
<dd>Implements a finite state machine. The variable <code>var</code> holds the
current state as a symbolic value. When a clause is found that contains the
current state in its CAAR <code>sym|lst</code> value, and either has no
<code>prg</code> condition in its CDDAR, or that condition returns
non-<code>NIL</code>, the current state will be set to the CADAR
<code>sym</code> of the clause, the body <code>prg</code> in its CDR will be
executed, and the result returned. <code>T</code> is a catch-all for any state.
If no state-condition matches, <code>NIL</code> is returned. See also <code><a
href="#case">case</a></code> and <code><a href="#job">job</a></code>.

<p><pre><code>
: (de tst ()
   (job '((Cnt . 4))
      (state '(start)
         ((start run) (printsp 'start))
         ((run run (gt0 (dec 'Cnt)))
            (printsp 'run) )
         ((run stop) (printsp 'run))
         ((stop start) (setq Cnt 4) (println 'stop)) ) ) )
-> tst
: (do 12 (tst))
start run run run run stop
start run run run run stop
-> stop
: (pp 'tst)
(de tst NIL
   (job '((Cnt . 4))
      (state '(start)
      ...
-> tst
: (do 3 (tst))
start run run -> run
: (pp 'tst)
(de tst NIL
   (job '((Cnt . 2))
      (state '(run)
      ...
-> tst
</code></pre>

<p><dt><a name="stem"><code>(stem 'lst 'any ..) -> lst</code></a>
<dd>Returns the tail of <code>lst</code> that does not contain any of the
<code>any</code> arguments. <code>(stem 'lst 'any ..)</code> is equivalent to
<code>(last (split 'lst 'any ..))</code>. See also <code><a
href="#tail">tail</a></code> and <code><a href="#split">split</a></code>.

<p><pre><code>
: (stem (chop "abc/def\\ghi") "/" "\\")
-> ("g" "h" "i")
</code></pre>

<p><dt><a name="stk"><code>(stk any ..) -> T</code></a>
<dd>Displays a dump of the internal runtime stack. All (unevaluated)
<code>any</code> arguments are printed as a header, then each stack entry is
printed per line, preceded by its (hexadecimal) address. See also <code><a
href="#env">env</a></code>.

<p><pre><code>
: (cons 'A (stk Test))
(Test)
BFFFF69C A
BFFFF70C (cons 'A (stk Test))

-> (A . T)
</code></pre>

<p><dt><a name="stamp"><code>(stamp ['dat 'tim]) -> sym</code></a>
<dd>Returns a date-time string in the form "YYYY-MM-DD HH:MM:SS". If
<code>dat</code> and/or <code>tim</code> is missing, the current date or time is
used. See also <code><a href="#date">date</a></code> and <code><a
href="#time">time</a></code>.

<p><pre><code>
: (stamp)
-> "2000-09-12 07:48:04"
: (stamp (date) 0)
-> "2000-09-12 00:00:00"
: (stamp (date 2000 1 1) (time 12 0 0))
-> "2000-01-01 12:00:00"
</code></pre>

<p><dt><a name="stat"><code>(stat) -> num</code></a>
<dd>Prints memory usage statistics. The total size of the heap (in million
cells), followed by the percentage of used cells. Returns the number of
currently used cells. See also <code><a href="#heap">heap</a></code>.

<p><pre><code>
: (stat)
1 7%
-> 66892
</code></pre>

<p><dt><a name="str"><code>(str 'sym) -> lst<br>
(str 'lst) -> sym</code></a>
<dd>In the first form, the string <code>sym</code> is parsed into a list. This
mechanism is also used by <code><a href="#load">load</a></code>. The second form
does the reverse operation by building a string from a list. See also <code><a
href="#any">any</a></code>, <code><a href="#name">name</a></code> and <code><a
href="#sym">sym</a></code>.

<p><pre><code>
: (str "a (1 2) b")
-> (a (1 2) b)
: (str '(a "Hello" DEF))
-> "a \"Hello\" DEF"
</code></pre>

<p><dt><a name="strip"><code>(strip 'any) -> any</code></a>
<dd>Strips all leading <code>quote</code> symbols from <code>any</code>.

<p><pre><code>
: (strip 123)
-> 123
: (strip '''(a))
-> (a)
: (strip (quote quote a b c))
-> (a b c)
</code></pre>

<p><dt><a name="strQ"><code>(str? 'any) -> sym | NIL</code></a>
<dd>Returns the argument <code>any</code> when it is a transient symbol
(string), otherwise <code>NIL</code>. See also <code><a
href="#symQ">sym?</a></code>, <code><a href="#boxQ">box?</a></code> and <code><a
href="#extQ">ext?</a></code>.

<p><pre><code>
: (str? 123)
-> NIL
: (str? '{ABC})
-> NIL
: (str? 'abc)
-> NIL
: (str? "abc")
-> "abc"
</code></pre>

<p><dt><a name="subQ"><code>(sub? 'sym1 'sym2) -> flg</code></a>
<dd>Returns non-<code>NIL</code> when the name of the first symbol
<code>sym1</code> is a substring of the name of the second symbol
<code>sym2</code>. See also <code><a href="#preQ">pre?</a></code>.

<p><pre><code>
: (sub? "def" "abcdef")
-> T
: (sub? "abb" "abcdef")
-> NIL
: (sub? "" "abcdef")
-> T
</code></pre>

<p><dt><a name="sum"><code>(sum 'fun 'lst ..) -> num</code></a>
<dd>Applies <code>fun</code> to each element of <code>lst</code>. When
additional <code>lst</code> arguments are given, their elements are also passed
to <code>fun</code>. Returns the sum of all numeric values returned from
<code>fun</code>.

<p><pre><code>
: (setq A 1  B 2  C 3)
-> 3
: (sum val '(A B C))
-> 6
: (sum                           # Total size of symbol list values
   '((X)
      (and (pair (val X)) (size @)) )
   (what) )
-> 32021
</code></pre>

<p><dt><a name="super"><code>(super ['any ..]) -> any</code></a>
<dd>Can only be used inside methods. Sends the current message to the current
object <code>This</code>, this time starting the search for a method at the
superclass(es) of the class where the current method was found.

<p><pre><code>
(dm stop> ()         # 'stop>' method of current class
   (super)           # Call the 'stop>' method of the superclass
   ... )             # other things
</code></pre>

<p><dt><a name="sym"><code>(sym 'any) -> sym</code></a>
<dd>Generate the printed representation of <code>any</code> into the name of a
new symbol <code>sym</code>. See also <code><a href="#any">any</a></code>,
<code><a href="#name">name</a></code> and <code><a href="#str">str</a></code>.

<p><pre><code>
: (sym '(abc "Hello" 123))
-> "(abc \"Hello\" 123)"
</code></pre>

<p><dt><a name="symQ"><code>(sym? 'any) -> flg</code></a>
<dd>Returns <code>T</code> when the argument <code>any</code> is a symbol. See
also <code><a href="#strQ">str?</a></code>, <code><a
href="#boxQ">box?</a></code> and <code><a href="#extQ">ext?</a></code>.

<p><pre><code>
: (sym? 'a)
-> T
: (sym? NIL)
-> T
: (sym? 123)
-> NIL
: (sym? '(a b))
-> NIL
</code></pre>

<p><dt><a name="sync"><code>(sync) -> flg</code></a>
<dd>Waits for pending data from all family processes. While other processes are
still sending data (via the <code><a href="#tell">tell</a></code> mechanism), a
<code>select</code> system call is executed for all file descriptors and timers
in the <code>VAL</code> of the global variable <code><a
href="#*Run">*Run</a></code>. See also <code><a href="#key">key</a></code> and
<code><a href="#wait">wait</a></code>.

<p><pre><code>
: (or (lock) (sync))       # Ensure database consistency
-> T                       # (numeric process-id if lock failed)
</code></pre>

<p><dt><a name="sys"><code>(sys 'any ['any]) -> sym</code></a>
<dd>Returns or sets a system environment variable.

<p><pre><code>
: (sys "TERM")                # Get current value
-> "xterm"
: (sys "TERM" "vt100")        # Set new value
-> "vt100"
: (sys "TERM")
-> "vt100"
</code></pre>


<p><hr>
<h3><a name="t-foo">T</a></h3>

<p><dt><a name="T"><code>T</code></a>
<dd>A global constant, evaluating to itself. <code>T</code> is commonly returned
as the boolean value "true" (though any non-<code>NIL</code> values could be
used). As a property key, it is used to store <a href="#pilog">Pilog</a>
clauses, and inside Pilog clauses it is the <i>cut</i> operator. See also
<code><a href="#nilSym">NIL</a></code>.

<p><pre><code>
: T
-> T
: (= 123 123)
-> T
: (get 'not T)
-> ((@P (1 -> @P) T (fail)) (@P))
</code></pre>

<p><dt><a name="This"><code>This</code></a>
<dd>Holds the current object during method execution (see <a href="#oop">OO
Concepts</a>), or inside the body of a <code><a href="#with">with</a></code>
statement. As it is a normal symbol, however, it can be used in normal bindings
anywhere.

<p><pre><code>
: (with 'X (println 'This 'is This))
This is X
-> X
: (put 'X 'a 1)
-> 1
: (put 'X 'b 2)
-> 2
: (put 'Y 'a 111)
-> 111
: (put 'Y 'b 222)
-> 222
: (mapcar '((This) (cons (: a) (: b))) '(X Y))
-> ((1 . 2) (111 . 222))
</code></pre>

<p><dt><a name="t"><code>(t . prg) -> T</code></a>
<dd>Executes <code>prg</code>, and returns <code>T</code>. See also <code><a
href="#nil">nil</a></code>, <code><a href="#prog">prog</a></code>, <code><a
href="#prog1">prog1</a></code> and <code><a href="#prog2">prog2</a></code>.

<p><pre><code>
: (t (println 'Ok))
Ok
-> T
</code></pre>

<p><dt><a name="tail"><code>(tail 'cnt|lst 'lst) -> lst</code></a>
<dd>Returns the last <code>cnt</code> elements of <code>lst</code>. If
<code>cnt</code> is negative, it is added to the length of <code>lst</code>. If
the first argument is a <code>lst</code>, <code>tail</code> is a predicate
function returning that argument list if it is <code>equal</code> to the tail of
the second argument, and <code>NIL</code> otherwise. See also <code><a
href="#head">head</a></code>. <code>(tail -2 Lst)</code> is equivalent to
<code>(nth Lst 3)</code>.

<p><pre><code>
: (tail 3 '(a b c d e f))
-> (d e f)
: (tail -2 '(a b c d e f))
-> (c d e f)
: (tail 0 '(a b c d e f))
-> NIL
: (tail 10 '(a b c d e f))
-> (a b c d e f)
: (tail '(d e f) '(a b c d e f))
-> (d e f)
</code></pre>

<p><dt><a name="tell"><code>(tell 'sym ['any ..]) -> any</code></a>
<dd>Family IPC: Send an executable list <code>(sym any ..)</code> to all family
members (i.e. all children of the current process, and all other children of the
parent process, see <code><a href="#fork">fork</a></code>) for automatic
execution. <code>tell</code> can also be used by <code><a
href="#commit">commit</a></code> to notify about database changes. See also
<code><a href="#rpc">rpc</a></code> and <code><a href="#hear">hear</a></code>.

<p><pre><code>
: (call 'ps "x")                            # Show processes
  PID TTY      STAT   TIME COMMAND
  ..
 1321 pts/0    S      0:00 bin/picolisp ..  # Parent process
 1324 pts/0    S      0:01 bin/picolisp ..  # First child
 1325 pts/0    S      0:01 bin/picolisp ..  # Second child
 1326 pts/0    R      0:00 ps x
-> T
: *Pid                                      # We are the second child
-> 1325
: (tell 'println '*Pid)                     # Ask all others to print their Pid's
1324
-> *Pid
</code></pre>

<p><dt><a name="text"><code>(text 'sym 'any ..) -> sym</code></a>
<dd>Builds a new transient symbol (string) from <code>sym</code>, by replacing
all occurrences of an at-mark "<code>@</code>", followed by one of the letters
"<code>1</code>" through "<code>9</code>", and "<code>A</code>" through
"<code>Z</code>", with the corresponding <code>any</code> argument. In this
context "<code>@A</code>" refers to the 10th argument. A literal at-mark in the
text can be represented by two successive at-marks. See also <code><a
href="#pack">pack</a></code> and <code><a href="#glue">glue</a></code>.

<p><pre><code>
:  (text "abc @1 def @2" 'XYZ 123)
-> "abc XYZ def 123"
: (text "a@@bc.@1" "de")
-> "a@bc.de"
</code></pre>

<p><dt><a name="throw"><code>(throw 'sym 'any)</code></a>
<dd>Non-local jump into a previous <code><a href="#catch">catch</a></code>
environment with the jump label <code>sym</code> (or <code>T</code> as a
catch-all). Any pending <code><a href="#finally">finally</a></code> expressions
are executed, local symbol bindings are restored, open files are closed and
internal data structures are reset appropriately, as the environment was at the
time when the corresponding <code>catch</code> was called. Then <code>any</code>
is returned from that <code>catch</code>.

<p><pre><code>
: (de foo (N)
   (println N)
   (throw 'Ok) )
-> foo
: (let N 1  (catch 'Ok (foo 7))  (println N))
7
1
-> 1
</code></pre>

<p><dt><a name="tick"><code>(tick (cnt1 . cnt2) . prg) -> any</code></a>
<dd>Executes <code>prg</code>, then (destructively) adds the number of elapsed
user ticks to the <code>cnt1</code> parameter, and the number of elapsed system
ticks to the <code>cnt2</code> parameter. Thus, <code>cnt1</code> and
<code>cnt2</code> will finally contain the total number of user and system time
ticks spent in <code>prg</code> and all functions called (this works also for
recursive functions). For execution profiling, <code>tick</code> is usually
inserted into words with <code>prof</code>, and removed with
<code>unprof</code>. See also <code><a href="#usec">usec</a></code>.

<p><pre><code>
: (de foo ()                        # Define function with empty loop
   (tick (0 . 0) (do 100000000)) )
-> foo
: (foo)                             # Execute it
-> NIL
: (pp 'foo)
(de foo NIL
   (tick (97 . 0) (do 100000000)) ) # 'tick' incremented 'cnt1' by 97
-> foo
</code></pre>

<p><dt><a name="till"><code>(till 'any ['flg]) -> lst|sym</code></a>
<dd>Reads from the current input channel till a character contained in
<code>any</code> is found. If <code>flg</code> is <code>NIL</code>, a list of
single-character transient symbols is returned. Otherwise, a single string is
returned. See also <code><a href="#from">from</a></code> and <code><a
href="#line">line</a></code>.

<p><pre><code>
: (till ":")
abc:def
-> ("a" "b" "c")
: (till ":" T)
abc:def
-> "abc"
</code></pre>

<p><dt><a name="time"><code>(time ['T]) -> tim<br>
(time 'tim) -> (h m s)<br>
(time 'h 'm ['s]) -> tim | NIL<br>
(time '(h m [s])) -> tim | NIL</code></a>
<dd>Calculates the time of day, represented as the number of seconds since
midnight. When called without arguments, the current local time is returned.
When called with a <code>T</code> argument, the current Coordinated Universal
Time (UTC) is returned. When called with a single number <code>tim</code>, it is
taken as a time value and a list with the corresponding hour, minute and second
is returned. When called with two or three numbers (or a list of two or three
numbers) for the hour, minute (and optionally the second), the corresponding
time value is returned (or <code>NIL</code> if they do not represent a legal
time). See also <code><a href="#date">date</a></code> and <code><a
href="#usec">usec</a></code>.

<p><pre><code>
: (time)                         # Now
-> 32334
: (time 32334)                   # Now
-> (8 58 54)
: (time 25 30)                   # Illegal time
-> NIL
</code></pre>

<p><dt><a name="touch"><code>(touch 'sym) -> sym</code></a>
<dd>When <code>sym</code> is an external symbol, it is marked as "modified" so
that upon a later <code><a href="#commit">commit</a></code> it will be written
to the database file. An explicit call of <code>touch</code> is only necessary
when the value or properties of <code>sym</code> are indirectly modified.

<p><pre><code>
: (get '{2} 'lst)
-> (1 2 3 4 5)
: (set (cdr (get (touch '{2}) 'lst)) 999)    # Only read-access, need 'touch'
-> 999
: (get '{2} 'lst)                            # Modified second list element
-> (1 999 3 4 5)
</code></pre>

<p><dt><a name="trace"><code>(trace 'sym) -> sym<br>
(trace 'sym 'cls) -> sym<br>
(trace '(sym . cls)) -> sym</code></a>
<dd>Inserts <code><a href="#$">$</a></code> trace function call at the beginning
of the function or method body of <code>sym</code>, so that trace information
will be printed before and after execution. Built-in functions
(<code>C</code>-function pointer) are automatically converted to Lisp
expressions.

<p><pre><code>
: (trace '+)
-> +
: (+ 3 4)
 + : 3 4
 + = 7
-> 7
</code></pre>

<p><dt><a name="trim"><code>(trim 'lst) -> lst</code></a>
<dd>Returns a copy of <code>lst</code> with all trailing white space characters
or <code>NIL</code> elements removed. See also <code><a
href="#clip">clip</a></code>.

<p><pre><code>
: (trim (1 NIL 2 NIL NIL))
-> (1 NIL 2)
: (trim '(a b " " " "))
-> (a b)
</code></pre>

<p><dt><a name="try"><code>(try 'msg 'any ['any ..]) -> any</code></a>
<dd>Tries to send the message <code>msg</code> to the object <code>obj</code>,
optionally with arguments <code>any</code>. If <code>any</code> is not an
object, or if the message cannot be located in <code>obj</code>, its classes and
superclasses, <code>NIL</code> is returned. See also <code><a
href="#send">send</a></code> and <code><a href="#method">method</a></code>.

<p><pre><code>
: (try 'msg> 123)
-> NIL
: (try 'html> 'a)
-> NIL
</code></pre>

<p><dt><a name="type"><code>(type 'any) -> lst</code></a>
<dd>Return the type (list of classes) of the object <code>sym</code>. See also
<code><a href="#isa">isa</a></code>.

<p><pre><code>
: (type '{1A;3})
(+Address)
</code></pre>


<p><hr>
<h3><a name="u-foo">U</a></h3>

<p><dt><a name="udp"><code>(udp 'any1 'cnt 'any2) -> any<br>
(udp 'cnt) -> any</code></a>
<dd>Simple unidirectional sending/receiving of UDP packets. In the first form,
<code>any2</code> is sent to a UDP server listening at host <code>any1</code>,
port <code>cnt</code>. In the second form, one item is received from a UDP
socket <code>cnt</code>, established with <code><a href="#port">port</a></code>.
See also <code><a href="#connect">connect</a></code>.

<p><pre><code>
# First session
: (port T 6666)
-> 3
: (udp 3)  # Receive a datagram

# Second session (on the same machine)
: (udp "localhost" 6666 '(a b c))
-> (a b c)

# First session
-> (a b c)
</code></pre>

<p><dt><a name="unify"><code>(unify 'any) -> lst</code></a>
<dd>Unifies <code>any</code> with the current <a href="#pilog">Pilog</a>
environment at the current level and with a value of <code>NIL</code>, and
returns the new environment or <code>NIL</code> if not successful. See also
<code><a href="#prove">prove</a></code> and <code><a
href="#lookup">-&gt</a></code>.

<p><pre><code>
: (? (@A unify '(@B @C)))
 @A=(((NIL . @C) 0 . @C) ((NIL . @B) 0 . @B) T)
</code></pre>

<p><dt><a name="unless"><code>(unless 'any . prg) -> any</code></a>
<dd>Conditional execution: When the condition <code>any</code> evaluates to
non-<code>NIL</code>, <code>NIL</code> is returned. Otherwise <code>prg</code>
is executed and the result returned. See also <code><a
href="#when">when</a></code>.

<p><pre><code>
: (unless (= 3 3) (println 'Strange 'result))
-> NIL
: (unless (= 3 4) (println 'Strange 'result))
Strange result
-> result
</code></pre>

<p><dt><a name="until"><code>(until 'any . prg) -> any</code></a>
<dd>Conditional loop: While the condition <code>any</code> evaluates to
<code>NIL</code>, <code>prg</code> is repeatedly executed. If <code>prg</code>
is never executed, <code>NIL</code> is returned. Otherwise the result of
<code>prg</code> is returned. See also <code><a href="#while">while</a></code>.

<p><pre><code>
: (until (=T (setq N (read)))
   (println 'square (* N N)) )
4
square 16
9
square 81
T
-> 81
</code></pre>

<p><dt><a name="up"><code>(up sym ['val]) -> any</code></a>
<dd>Looks up (or modifies) the previously saved value of <code>sym</code> in the
enclosing environment. See also <code><a href="#eval">eval</a></code>, <code><a
href="#run">run</a></code> and <code><a href="#env">env</a></code>.

<p><pre><code>
: (let N 1 ((quote (N) (println N (up N))) 2))
2 1
-> 1
: (let N 1 ((quote (N) (println N (up N) (up N 7))) 2) N)
2 1 7
-> 7
</code></pre>

<p><dt><a name="uppQ"><code>(upp? 'any) -> sym | NIL</code></a>
<dd>Returns <code>any</code> when the argument is a string (symbol) that starts
with an uppercase character. See also <code><a href="#uppc">uppc</a></code>.

<p><pre><code>
: (upp? "A")
-> T
: (upp? "a")
-> NIL
: (upp? 123)
-> NIL
: (upp? ".")
-> NIL
</code></pre>

<p><dt><a name="uppc"><code>(uppc 'any) -> any</code></a>
<dd>Upper case conversion: If <code>any</code> is not a symbol, it is returned
as it is. Otherwise, a new transient symbol with all characters of
<code>any</code>, converted to upper case, is returned. See also <code><a
href="#lowc">lowc</a></code>, <code><a href="#fold">fold</a></code> and <code><a
href="#uppQ">upp?</a></code>.

<p><pre><code>
: (uppc 123)
-> 123
: (uppc "abc")
-> "ABC"
: (uppc 'car)
-> "CAR"
</code></pre>

<p><dt><a name="use"><code>(use sym . prg) -> any<br>
(use (sym ..) . prg) -> any</code></a>
<dd>Defines local variables. The value of the symbol <code>sym</code> - or the
values of the symbols <code>sym</code> in the list of the second form - are
saved, <code>prg</code> is executed, then the symbols are restored to their
original values. During execution of <code>prg</code>, the values of the symbols
can be temporarily modified. The return value is the result of <code>prg</code>.
See also <code><a href="#bind">bind</a></code>, <code><a
href="#job">job</a></code> and <code><a href="#let">let</a></code>.

<p><pre><code>
: (setq  X 123  Y 456)
-> 456
: (use (X Y) (setq  X 3  Y 4) (* X Y))
-> 12
: X
-> 123
: Y
-> 456
</code></pre>

<p><dt><a name="usec"><code>(usec) -> num</code></a>
<dd>Returns the number the microseconds since interpreter startup. See also
<code><a href="#time">time</a></code> and <code><a href="#tick">tick</a></code>.

<p><pre><code>
: (usec)
-> 1154702479219050
</code></pre>


<p><hr>
<h3><a name="v-foo">V</a></h3>

<p><dt><a name="val"><code>(val 'var) -> any</code></a>
<dd>Returns the current value of <code>var</code>.

<p><pre><code>
: (setq L '(a b c))
-> (a b c)
: (val 'L)
-> (a b c)
: (val (cdr L))
-> b
</code></pre>


<p><hr>
<h3><a name="w-foo">W</a></h3>

<p><dt><a name="wait"><code>(wait ['cnt] . prg) -> any</code></a>
<dd>Waits for a condition. While the result of the execution of <code>prg</code>
returns non-<code>NIL</code>, a <code>select</code> system call is executed for
all file descriptors and timers in the <code>VAL</code> of the global variable
<code><a href="#*Run">*Run</a></code>. When <code>cnt</code> is
non-<code>NIL</code>, the waiting time is limited to <code>cnt</code>
milliseconds. See also <code><a href="#key">key</a></code> and <code><a
href="#sync">sync</a></code>.

<p><pre><code>
: (wait 2000)                                # Wait 2 seconds
-> NIL
: (prog
   (zero *Cnt)
   (setq *Run                                # Install background loop
      '((-2000 0 (println (inc '*Cnt)))) )   # Increment '*Cnt' every 2 sec
   (wait NIL (> *Cnt 6))                     # Wait until > 6
   (off *Run) )
1                                            # Waiting ..
2
3
4
5
6
7
-> NIL
</code></pre>

<p><dt><a name="when"><code>(when 'any . prg) -> any</code></a>
<dd>Conditional execution: When the condition <code>any</code> evaluates to
non-<code>NIL</code>, <code>prg</code> is executed and the result is returned.
Otherwise <code>NIL</code> is returned. See also <code><a
href="#unless">unless</a></code>.

<p><pre><code>
: (when (> 4 3) (println 'Ok) (println 'Good))
Ok
Good
-> Good
</code></pre>

<p><dt><a name="while"><code>(while 'any . prg) -> any</code></a>
<dd>Conditional loop: While the condition <code>any</code> evaluates to
non-<code>NIL</code>, <code>prg</code> is repeatedly executed. If
<code>prg</code> is never executed, <code>NIL</code> is returned. Otherwise the
result of <code>prg</code> is returned. See also <code><a
href="#until">until</a></code>.

<p><pre><code>
: (while (read)
   (println 'got: @) )
abc
got: abc
1234
got: 1234
NIL
-> 1234
</code></pre>

<p><dt><a name="wipe"><code>(wipe 'sym|lst) -> sym|lst</code></a>
<dd>Clears the <code>VAL</code> and the property list of <code>sym</code>, or of
all symbols in the list <code>lst</code>. When a symbol is an external symbol,
its state is also set to "not loaded". Does nothing when <code>sym</code> is an
external symbol that has been modified or deleted ("dirty").

<p><pre><code>
: (setq A (1 2 3 4))
-> (1 2 3 4)
: (put 'A 'a 1)
-> 1
: (put 'A 'b 2)
-> 2
: (show 'A)
A (1 2 3 4)
   b 2
   a 1
-> A
: (wipe 'A)
-> A
: (show 'A)
A NIL
-> A
</code></pre>

<p><dt><a name="with"><code>(with 'sym . prg) -> any</code></a>
<dd>Saves the current object <code>This</code> and sets it to the new value
<code>sym</code>. Then <code>prg</code> is executed, and <code>This</code> is
restored to its previous value. The return value is the result of
<code>prg</code>. Used typically to access the local data of <code>sym</code> in
the same manner as inside a method body. <code>prg</code> is not executed (and
<code>NIL</code> is returned) when <code>sym</code> is <code>NIL</code>.
<code>(with 'X . prg)</code> is equivalent to <code>(let? This 'X . prg)</code>.

<p><pre><code>
: (put 'X 'a 1)
-> 1
: (put 'X 'b 2)
-> 2
: (with 'X (list (: a) (: b)))
-> (1 2)
</code></pre>

<p><dt><a name="wr"><code>(wr 'num ..) -> num</code></a>
<dd>Writes all <code>num</code> arguments as raw bytes to the current output
channel. See also <code><a href="#rd">rd</a></code> and <code><a
href="#pr">pr</a></code>.

<p><pre><code>
: (out "x" (wr 1 255 257))                   # Write to "x"
-> 257
: (hd "x")
00000000  01 FF 01                                         ...
-> NIL
</code></pre>


<p><hr>
<h3><a name="x-foo">X</a></h3>

<p><dt><a name="xchg"><code>(xchg 'var 'var ..) -> any</code></a>
<dd>Exchange the values of successive <code>var</code> argument pairs.

<p><pre><code>
: (setq  A 1  B 2  C '(a b c))
-> (a b c)
: (xchg  'A C  'B (cdr C))
-> 2
: A
-> a
: B
-> b
: C
-> (1 2 c)
</code></pre>

<p><dt><a name="xor"><code>(xor 'any 'any) -> flg</code></a>
<dd>Returns T if exactly one of the arguments evaluates to non-<code>NIL</code>.

<p><pre><code>
: (xor T NIL)
-> T
: (xor T T)
-> NIL
</code></pre>

<p><dt><a name="x|"><code>(x| 'num ..) -> num</code></a>
<dd>Returns the bitwise <code>XOR</code> of all <code>num</code> arguments. See
also <code><a href="#&">&</a></code>, <code><a href="#|">|</a></code> and
<code><a href="#bitQ">bit?</a></code>.

<p><pre><code>
: (x| 2 7)
-> 5
: (x| 2 7 1)
-> 4
</code></pre>


<p><hr>
<h3><a name="y-foo">Y</a></h3>


<p><hr>
<h3><a name="z-foo">Z</a></h3>


<p><dt><a name="zap"><code>(zap 'sym) -> sym</code></a>
<dd>"Delete" the symbol <code>sym</code>. For internal symbols, that means to
remove it from the internal hash table, effectively transforming it to a
transient symbol. For external symbols, it means to mark it as "deleted", so
that upon a later <code><a href="#commit">commit</a></code> it will be removed
from the database file. See also <code><a href="#intern">intern</a></code>.

<p><pre><code>
: (de foo (Lst) (car Lst))          # 'foo' calls 'car'
-> foo
: (zap 'car)                        # Delete the symbol 'car'
-> "car"
: (pp 'foo)
(de foo (Lst)
   ("car" Lst) )                    # 'car' is now a transient symbol
-> foo
: (foo (1 2 3))                     # 'foo' still works
-> 1
: (car (1 2 3))                     # Reader returns a new 'car' symbol
!? (car (1 2 3))
car -- Undefined
?
</code></pre>

<p><dt><a name="zero"><code>(zero sym ..) -> 0</code></a>
<dd>Stores <code>0</code> in the <code>VAL</code>'s of all argument symbols
<code>sym</code>. See also <code><a href="#one">one</a></code>, <code><a
href="#on">on</a></code>, <code><a href="#off">off</a></code> and <code><a
href="#onOff">onOff</a></code>.

<p><pre><code>
: (zero A B)
-> 0
: A
-> 0
: B
-> 0
</code></pre>


<p><hr>
<h3><a name="pun-foo">Other</a></h3>

<p><dt><a name="!"><code>(! . prg) -> any</code></a>
<dd>Low level breakpoint function: The current execution environment is saved
and the I/O channels are redirected to the console. Then <code>prg</code> is
displayed, and a read-eval-print-loop is entered (with <code>!</code> as its
prompt character), to evaluate expressions and examine the current program
environment. An empty input line terminates the read-eval-print-loop, the
environment and I/O channels are restored, and the result of <code>prg</code> is
returned. <code>!</code> is normally inserted into existing programs with the
<code><a href="#debug">debug</a></code> function. See also <code><a
href="#e">e</a></code>, <code><a href="#^">^</a></code> and <code><a
href="#*Dbg">*Dbg</a></code>.

<p><pre><code>
: (de foo (N) (and (println 1) (! println N) (println 2)))
-> foo
: (foo 7)
1                 # Executed '(println 1)'
(println N)       # Entered breakpoint
! N               # Examine the value of 'N'
-> 7
! (e)             # Evaluate '^', i.e. (println N)
7
-> 7
! (e @)           # Evaluate '@' -> the result of '(println 1)'
-> 1
!                 # Empty line: continue
7                 # Executed '(println N)'
2                 # Executed '(println 2)'
-> 2
</code></pre>

<p><dt><a name="$"><code>($ sym|lst lst . prg) -> any</code></a>
<dd>Low level trace function: The first argument <code>sym|lst</code> is printed
to the console with a proper indentation, followed by a colon <code>:</code>. If
a function is traced, the first argument is the function symbol, else if a
method is traced, it is a cons pair of message and class. The second argument
<code>lst</code> should be a list of symbols, identical to the function's
argument list. The current values of these symbols are printed, followed by a
newline. Then <code>prg</code> is executed, and its return value printed in a
similar way (this time with an equals sign <code>=</code> instead of a colon)
and returned. <code>$</code> is normally inserted into existing programs with
the <code><a href="#trace">trace</a></code> function.

<p><pre><code>
: (de foo (A B) ($ foo (A B) (* A B)))
-> foo
: (foo 3 4)
 foo : 3 4        # Function entry, arguments 3 and 4
 foo = 12         # Function exit, return value 12
-> 12
</code></pre>

<p><dt><a name="%"><code>(% 'num ..) -> num</code></a>
<dd>Returns the remainder from the divisions of successive <code>num</code>
arguments. The sign of the result is that of the first argument.

<p><pre><code>
: (% 17 5)
-> 2
: (% -17 5)  # Sign is that of the first argument
-> -2
: (% 5 2)
-> 1
: (% 15 10)
-> 5
: (% 15 10 2)  # (% 15 10) -> 5, then (% 5 2) -> 1
-> 1
</code></pre>

<p><dt><a name="&"><code>(& 'num ..) -> num</code></a>
<dd>Returns the bitwise <code>AND</code> of all <code>num</code> arguments. See
also <code><a href="#|">|</a></code>, <code><a href="#x|">x|</a></code> and
<code><a href="#bitQ">bit?</a></code>.

<p><pre><code>
: (& 6 3)
-> 2
: (& 7 3 1)
-> 1
</code></pre>

<p><dt><a name="*"><code>(* 'num ..) -> num</code></a>
<dd>Returns the product of all <code>num</code> arguments.

<p><pre><code>
: (* 1 2 3)
-> 6
: (* 5 3 2 2)
-> 60
</code></pre>

<p><dt><a name="*/"><code>(*/ 'num1 ['num2 ..] 'num3) -> num</code></a>
<dd>Returns the product of <code>num1</code> and all following <code>num2</code>
arguments, divided by the <code>num3</code> argument. The result is rounded to
the nearest integer value.

<p><pre><code>
: (*/ 3 4 2)
-> 6
: (*/ 1234 2 10)
-> 247
: (*/ 100 6)
-> 17
</code></pre>

<p><dt><a name="*Adr"><code>*Adr</code></a>
<dd>A global variable holding the IP address of last recently accepted client.
See also <code><a href="#listen">listen</a></code> and <code><a
href="#accept">accept</a></code>.

<p><pre><code>
: *Adr
-> "127.0.0.1"
</code></pre>

<p><dt><a name="*Bye"><code>*Bye</code></a>
<dd>A global variable holding a (possibly empty) <code>prg</code> body, to be
executed just before the termination of the Pico Lisp interpreter.

<p><pre><code>
: (push '*Bye '(call 'rm "-r" *Tmp))   # Remove all temporary files
-> (call 'rm "-r" *Tmp)
</code></pre>

<p><dt><a name="*Class"><code>*Class</code></a>
<dd>A global variable holding the current class.

<p><pre><code>
: (class +Test)
-> +Test
: *Class
-> +Test
</code></pre>

<p><dt><a name="*DB"><code>*DB</code></a>
<dd>A global constant holding the external symbol <code>{1}</code>, the database
root. All transient symbols in a database can be reached from that root. Except
during debugging, any explicit literal access to symbols in the database should
be avoided, because otherwise a memory leak might occur (The garbage collector
temporarily sets <code>*DB</code> to <code>NIL</code> and restores its value
after collection, thus disposing of all external symbols not currently used in
the program).

<p><pre><code>
: (show *DB)
{1} NIL
   +City {P}
   +Person {3}
-> {1}
: (show '{P})
{P} NIL
   nm (566 . {AhDx})
-> {P}
: (show '{3})
{3} NIL
   tel (681376 . {Agyl})
   nm (1461322 . {2gu7})
-> {3}
</code></pre>

<p><dt><a name="*Dbg"><code>*Dbg</code></a>
<dd>A boolean variable controlling the <code><a href="#$">$</a></code> (tracing)
and <code><a href="#!">!</a></code> (breakpoint) functions. They are enabled
when <code>*Dbg</code> is non-<code>NIL</code>.

<p><pre><code>
: (de foo (A B) (* A B))
-> foo
: (trace 'foo)
-> foo
: (foo 3 4)
 foo : 3 4
 foo = 12
-> 12
: (let *Dbg NIL (foo 3 4))
-> 12
</code></pre>

<p><dt><a name="*Err"><code>*Err</code></a>
<dd>A global variable holding a (possibly empty) <code>prg</code> body, which
will be executed during error processing. See also <code><a href="#errors">Error
Handling</a></code>, <code><a href="#*Rst">*Rst</a></code> and <code><a
href="#*Msg">*Msg</a></code>.

<p><pre><code>
: (de *Err (prinl "Fatal error!"))
-> ((prinl "Fatal error!"))
: (/ 3 0)
!? (/ 3 0)
Div/0
Fatal error!
$
</code></pre>

<p><dt><a name="*Fork"><code>*Fork</code></a>
<dd>A global variable holding a (possibly empty) <code>prg</code> body, to be
executed after a call to <code><a href="#fork">fork</a></code> in the child
process.

<p><pre><code>
: (push '*Fork '(off *Tmp))   # Clear '*Tmp' in child process
-> (off *Tmp)
</code></pre>

<p><dt><a name="*Led"><code>*Led</code></a>
<dd>A global variable holding a (possibly empty) <code>prg</code> body that
implements a "Line editor". When non-<code>NIL</code>, it should return a single
symbol (string) upon execution.

<p><pre><code>
: (de *Led "(bye)")
# *Led redefined
-> *Led
: $                                    # Exit
</code></pre>

<p><dt><a name="*Msg"><code>*Msg</code></a>
<dd>A global variable holding the last recently issued error message. See also
<code><a href="#errors">Error Handling</a></code>, <code><a
href="#*Err">*Err</a></code> and <code><a href="#*Rst">*Rst</a></code>.

<p><pre><code>
: (+ 'A 2)
!? (+ 'A 2)
A -- Number expected
?
:
: *Msg
-> "Number expected"
</code></pre>

<p><dt><a name="*PPid"><code>*PPid</code></a>
<dd>A global constant holding the process-id of the parent picolisp process, or
<code>NIL</code> if the current process is a top level process.

<p><pre><code>
: (println *PPid *Pid)
NIL 5286

: (unless (fork) (println *PPid *Pid) (bye))
5286 5522
</code></pre>

<p><dt><a name="*Pid"><code>*Pid</code></a>
<dd>A global constant holding the current process-id.

<p><pre><code>
: *Pid
-> 6386
: (call "ps")                          # Show processes
  PID TTY          TIME CMD
 .... ...      ........ .....
 6386 pts/1    00:00:00 bin/picolisp   # <- current process
 6388 pts/1    00:00:00 ps
-> T
</code></pre>

<p><dt><a name="*Rst"><code>*Rst</code></a>
<dd>A global variable holding a (possibly empty) <code>prg</code> body, which
will be executed after error processing. This makes it possible to restart an
application despite of a failure. See also <code><a href="#errors">Error
Handling</a></code>, <code><a href="#*Err">*Err</a></code> and <code><a
href="#*Msg">*Msg</a></code>.

<p><pre><code>
: (de loopTest ()
   (let N 4
      (loop
         (println (/ 100 (dec 'N))) ) ) )
-> loopTest
: (de *Rst
   (prinl "Loop Failed!")
   (wait 4000)
   (loopTest) )  # restart
-> *Rst
: (loopTest)
33
50
100
!? (/ 100 (dec 'N))
Div/0
Loop Failed!
33
50
100
!? (/ 100 (dec 'N))
Div/0
Loop Failed!
...
</code></pre>

<p><dt><a name="*Run"><code>*Run</code></a>
<dd>This global variable can hold a list of <code>prg</code> expressions which
are used during <code><a href="#key">key</a></code>, <code><a
href="#sync">sync</a></code> and <code><a href="#wait">wait</a></code>. The
first element of each expression must either be a positive number (thus denoting
a file descriptor to wait for) or a negative number (denoting a timeout value in
milliseconds (in that case another number must follow to hold the remaining
time)). A <code>select</code> system call is performed with these values, and
the corresponding <code>prg</code> body is executed when input data are
available or when a timeout occurred.

<p><pre><code>
: (de *Run (-2000 0 (println '2sec)))     # Install 2-sec-timer
-> *Run
: 2sec                                    # Prints "2sec" every 2 seconds
2sec
2sec
                                          # (Enter) Exit
$
</code></pre>

<p><dt><a name="*Scl"><code>*Scl</code></a>
<dd>A global variable holding the current fixed-point input scale. See also
<code><a href="#num-io">Numbers</a></code>. The value can be locally overridden
with the <code>scl</code> function:

<p><pre><code>
: (pp 'scl)
(de scl (*Scl . "Prg")
   (run "Prg") )
-> scl
: (str "123.45")                 # Default value of '*Scl' is 0
-> (123)
: (scl 0 (str "123.45"))
-> (123)
: (scl 3 (str "123.45"))
-> (123450)
</code></pre>

<p><dt><a name="*Solo"><code>*Solo</code></a>
<dd>A global variable indicating exclusive database access. Its value is
<code>0</code> initially, set to <code>T</code> (or <code>NIL</code>) during
cooperative database locks when <code><a href="#lock">lock</a></code> is
successfully called with a <code>NIL</code> (or non-<code>NIL</code>) argument.

<p><pre><code>
: *Solo
-> 0
: (lock *DB)
-> NIL
: *Solo
-> NIL
: (rollback)
-> T
: *Solo
-> 0
: (lock)
-> NIL
: *Solo
-> T
: (rollback)
-> T
: *Solo
-> T
</code></pre>

<p><dt><a name="*Uni"><code>*Uni</code></a>
<dd>A global variable holding all unique data that were collected with the comma
(<code>,</code>) read-macro. See also <code><a
href="#macro-io">Read-Macros</a></code>.

<p><pre><code>
: (off *Uni)            # Clear
-> NIL
: ,"abc"                # Collect a transient symbol
-> "abc"
: ,(1 2 3)              # Collect a list
-> (1 2 3)
: *Uni
-> ((1 2 3) "abc")
</code></pre>

<p><dt><a name="+"><code>(+ 'num ..) -> num</code></a>
<dd>Returns the sum of all <code>num</code> arguments.

<p><pre><code>
: (+ 1 2 3)
-> 6
</code></pre>

<p><dt><a name="-"><code>(- 'num ..) -> num</code></a>
<dd>Returns the difference of the first <code>num</code> argument and all
following arguments. If only a single argument is given, it is negated.

<p><pre><code>
: (- 7)
-> -7
: (- 7 2 1)
-> 4
</code></pre>

<p><dt><a name="/"><code>(/ 'num ..) -> num</code></a>
<dd>Returns the the first <code>num</code> argument successively divided by all
following arguments.

<p><pre><code>
: (/ 12 3)
-> 4
: (/ 60 3 2 2)
</code></pre>

<p><dt><a name=":"><code>(: sym|0 [sym1|cnt ..]) -> any</code></a>
<dd>Fetches a value <code>any</code> from the properties of a symbol, or from a
list, by applying the <code><a href="#get">get</a></code> algorithm to
<code>This</code> and the following arguments. Used typically in methods or
<code><a href="#with">with</a></code> bodies. See also <code><a
href="#get">get</a></code>, <code><a href="#=:">=:</a></code> and <code><a
href="#::">::</a></code>.

<p><pre><code>
: (put 'X 'a 1)
-> 1
: (with 'X (: a))
-> 1
</code></pre>

<p><dt><a name="::"><code>(:: sym [sym1|cnt .. sym2]) -> lst|sym</code></a>
<dd>Fetches a property for a property key <code>sym</code> or <code>sym2</code>
from a symbol. That symbol is <code>This</code> (if no other arguments are
given), or a symbol found by applying the <code><a href="#get">get</a></code>
algorithm to <code>This</code> and the following arguments. The property (the
cell, not just its value) is returned, suitable for direct (destructive)
manipulations. Used typically in methods or <code><a
href="#with">with</a></code> bodies. See also <code><a href="#=:">=:</a></code>
and <code><a href="#:">:</a></code>.

<p><pre><code>
: (with 'X (=: cnt 0) (inc (:: cnt)) (: cnt))
-> 1
</code></pre>

<p><dt><a name="<"><code>(< 'any ..) -> flg</code></a>
<dd>Returns <code>T</code> when all arguments <code>any</code> are in strictly
increasing order. See also <a href="#cmp">Comparing</a>.

<p><pre><code>
: (< 3 4)
-> T
: (< 'a 'b 'c)
-> T
: (< 999 'a)
-> T
</code></pre>

<p><dt><a name="<="><code>(<= 'any ..) -> flg</code></a>
<dd>Returns <code>T</code> when all arguments <code>any</code> are in strictly
non-decreasing order. See also <a href="#cmp">Comparing</a>.

<p><pre><code>
: (<= 3 3)
-> T
: (<= 1 2 3)
-> T
: (<= "abc" "abc" "def")
-> T
</code></pre>

<p><dt><a name="<>"><code>(<&gt 'any ..) -> flg</code></a>
<dd>Returns <code>T</code> when not all <code>any</code> arguments are equal
(structure equality). <code>(<&gt 'any ..)</code> is equivalent to <code>(not (=
'any ..))</code>. See also <a href="#cmp">Comparing</a>.

<p><pre><code>
: (<&gt 'a 'b)
-> T
: (<&gt 'a 'b 'b)
-> T
: (<&gt 'a 'a 'a)
-> NIL
</code></pre>

<p><dt><a name="="><code>(= 'any ..) -> flg</code></a>
<dd>Returns <code>T</code> when all <code>any</code> arguments are equal
(structure equality). See also <a href="#cmp">Comparing</a>.

<p><pre><code>
: (= 6 (* 1 2 3))
-> T
: (= "a" "a")
-> T
: (== "a" "a")
-> T
: (= (1 (2) 3) (1 (2) 3))
-> T
</code></pre>

<p><dt><a name="=0"><code>(=0 'any) -> num | NIL</code></a>
<dd>Returns <code>0</code> when <code>any</code> is a number with value zero.
See also <code><a href="#n0">n0</a></code>, <code><a href="#lt0">lt0</a></code>,
<code><a href="#ge0">ge0</a></code> and <code><a href="#gt0">gt0</a></code>.

<p><pre><code>
: (=0 (- 6 3 2 1))
-> 0
: (=0 'a)
-> NIL
</code></pre>

<p><dt><a name="=:"><code>(=: sym [sym1|cnt .. sym2] 'any)</code></a>
<dd>Stores a new value <code>any</code> for a property key <code>sym</code> or
<code>sym2</code> in a symbol. That symbol is <code>This</code> (if no other
arguments are given), or a symbol found by applying the <code><a
href="#get">get</a></code> algorithm to <code>This</code> and the following
arguments. Used typically in methods or <code><a href="#with">with</a></code>
bodies. See also <code><a href="#put">put</a></code>, <code><a
href="#:">:</a></code> and <code><a href="#::">::</a></code>.

<p><pre><code>
: (with 'X (=: a 1) (=: b 2))
-> 2
: (get 'X 'a)
-> 1
: (get 'X 'b)
-> 2
</code></pre>

<p><dt><a name="=="><code>(== 'any ..) -> flg</code></a>
<dd>Returns <code>T</code> when all <code>any</code> arguments are the same
(pointer equality). See also <code><a href="#n==">n==</a></code>.

<p><pre><code>
: (== 'a 'a)
-> T
: (== 'NIL NIL (val NIL) (car NIL) (cdr NIL))
-> T
: (== 6 (* 1 2 3))
-> NIL
</code></pre>

<p><dt><a name="===="><code>(==== ['sym ..]) -> NIL</code></a>
<dd>Close the current transient scope by clearing the transient hash table. All
transient symbols become hidden and inaccessible by the reader. Then any
optional <code>sym</code> arguments are inserted into the transient hash table.
See also <code><a href="#extern">extern</a></code> and <code><a
href="#intern">intern</a></code>.

<p><pre><code>
: (setq S "abc")           # Read "abc"
-> "abc"
: (== S "abc")             # Read again, get the same symbol
-> T
: (====)                   # Close scope
-> NIL
: (== S "abc")             # Read again, get another symbol
-> NIL
</code></pre>

<p><dt><a name="=T"><code>(=T 'any) -> flg</code></a>
<dd>Returns <code>T</code> when <code>any</code> is the symbol <code>T</code>.
<code>(=T X)</code> is equivalent to <code>(== T X)</code>. See also <a
href="#nT">nT</a>.

<p><pre><code>
: (=T 0)
-> NIL
: (=T "T")
-> NIL
: (=T T)
-> T
</code></pre>

<p><dt><a name=">"><code>(> 'any ..) -> flg</code></a>
<dd>Returns <code>T</code> when all arguments <code>any</code> are in strictly
decreasing order. See also <a href="#cmp">Comparing</a>.

<p><pre><code>
: (> 4 3)
-> T
: (> 'A 999)
-> T
</code></pre>

<p><dt><a name=">="><code>(>= 'any ..) -> flg</code></a>
<dd>Returns <code>T</code> when all arguments <code>any</code> are in strictly
non-increasing order. See also <a href="#cmp">Comparing</a>.

<p><pre><code>
: (>= 'A 999)
-> T
: (>= 3 2 2 1)
-> T
</code></pre>

<p><dt><a name=">>"><code>(>> 'cnt 'num) -> num</code></a>
<dd>Shifts right the <code>num</code> argument by <code>cnt</code>
bit-positions. If <code>cnt</code> is negative, a corresponding left shift is
performed.

<p><pre><code>
: (>> 1 8)
-> 4
: (>> 3 16)
-> 2
: (>> -3 16)
-> 128
: (>> -1 -16)
-> -32
</code></pre>

<p><dt><a name="quest"><code>(? [sym 'any ..] . lst) -> flg</code></a>
<dd>Top-level function for interactive <a href="#pilog">Pilog</a> queries. It
displays each result, waits for console input, and terminates when a non-empty
line is entered.

<p><pre><code>
: (? (append (a b c) (d e f) @X))
 @X=(a b c d e f)
-> NIL

: (? (append @X @Y (a b c)))
 @X=NIL @Y=(a b c)
 @X=(a) @Y=(b c)
 @X=(a b) @Y=(c)
 @X=(a b c) @Y=NIL
-> NIL

: (? (append @X @Y (a b c)))
 @X=NIL @Y=(a b c).                       # Stopped
-> NIL
</code></pre>

<p><dt><a name="@"><code>@</code></a>
<dd>Holds the result of the last top level expression in the current
read-eval-print loop, or the result of the conditional expression during the
evaluation of flow functions (see <code><a href="#atres">@ Result</a></code>).
When <code>@</code> is used as a formal parameter in <a href="#lambda">lambda
expressions</a>, it denotes a variable number of evaluated arguments.

<dt><a name="@@"><code>@@</code></a>
<dd>Holds the result of the second last top level expression in the current
read-eval-print loop (see <code><a href="#atres">@ Result</a></code>).

<dt><a name="@@@"><code>@@@</code></a>
<dd>Holds the result of the third last top level expression in the current
read-eval-print loop (see <code><a href="#atres">@ Result</a></code>).

<dt><a name="^"><code>^</code></a>
<dd>Holds the currently executed expression during a breakpoint or an error. See
also <code><a href="#debug">debug</a></code>, <code><a href="#!">!</a></code>,
<code><a href="#e">e</a></code> and <code><a href="#*Dbg">*Dbg</a></code>.

<p><pre><code>
: (* (+ 3 4) (/ 7 0))
!? (/ 7 0)
Div/0
? ^
-> (/ 7 0)
</code></pre>

<p><dt><a name="|"><code>(| 'num ..) -> num</code></a>
<dd>Returns the bitwise <code>OR</code> of all <code>num</code> arguments. See
also <code><a href="#x|">x|</a></code>, <code><a href="#&">&</a></code> and
<code><a href="#bitQ">bit?</a></code>.

<p><pre><code>
: (| 1 2)
-> 3
: (| 1 2 4 8)
-> 15
</code></pre>

</dl>


<p><hr>
<h2><a name="down">Download</a></h2>

<p>The <code>Pico Lisp</code> system can be downloaded from the <a
href="http://software-lab.de/down.html">Pico Lisp Download</a> page.

</body>
</html>
